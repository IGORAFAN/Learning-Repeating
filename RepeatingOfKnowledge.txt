 - Malloc просто выделяет память, если malloc не сможет выделить память, он возвращает нулевой указатель. 
 - New выделяет память, а так же вызвает конструктор у обьекта класса, если new не смог выделить память, он бросает исключение bad_alloc.
 - mutable нужен для указания того, что данная переменная ( mutable int someVar ) может изменяться даже в константных методах.
 - volatile - команда компилятору что переменная ( volatile int someVar ) может изменяться в любой runtime момент и компилятор не имеет права её с оптимизировать и потереть в ней значения.
 - implicit - исключаеть не явное преобразование конструктора под другой тип данных.

 - Наследование:
 	- при :public наследовании, то ничего не меняется
 	- при :private наследовании, то protected и public становятся private
 	- при :protected наследовании, то public становятся protected

 - STL:
    - Контейнеры:
        - Последовательные: 
            - vector - это динамический массив, способный увеличиваться по мере необходимости для содержания всех своих элементов. Класс vector обеспечивает произвольный доступ к своим элементам через оператор индексации [], а также поддерживает добавление и удаление элементов.

            - deque - это двусторонняя очередь, реализованная в виде динамического массива, который может расти с обоих концов.

            - array - это массив чего угодно, создание массива требует строгого обявления размера массива.

            - list - это двусвязный список, каждый элемент которого содержит 2 указателя: один указывает на следующий элемент списка, а другой — на предыдущий элемент списка. List предоставляет доступ только к началу и к концу списка — произвольный доступ запрещен. Преимуществом двусвязного списка является то, что добавление элементов происходит очень быстро. Обычно для перебора элементов двусвязного списка используются итераторы.

            - forward_list - это односвязный список
            - basic_string - это массив символов c помощью которого можно хранить любых видов символы. std::string - это typedef на basic_string<char>

        - Ассоциативные:
            - set - это контейнер, в котором хранятся только уникальные элементы, и повторения запрещены. Элементы сортируются в соответствии с их значениями.

            - multiset - это set, но в котором допускаются повторяющиеся элементы.

            - map - это set, в котором каждый элемент является парой «ключ-значение». «Ключ» используется для сортировки и индексации данных и должен быть уникальным, а «значение» — это фактические данные. Реализован на основании красно-черного дерева.

            - multimap - это map, который допускает дублирование ключей. Все ключи отсортированы в порядке возрастания, и вы можете посмотреть значение по ключу.

            - unordored_map - это map у которого ввиде уникального ключа используется хеш-сума. Ключи храняться в хаотичном порядке.
            
            - unordered_set - это set у которого ввиде уникального ключа используется хеш-сума. Ключи храняться в хаотичном порядке.

        - Адаптеры:
            - stack - это контейнерный класс, элементы которого работают по принципу LIFO (англ. «Last In, First Out» = «последним пришел, первым ушел»), т.е. элементы добавляются (вносятся) в конец контейнера и удаляются (выталкиваются) оттуда же (из конца контейнера). Обычно в стеках используется deque в качестве последовательного контейнера по умолчанию (что немного странно, поскольку vector был бы более подходящим вариантом), но вы также можете использовать vector или list.

            - queue - это контейнерный класс, элементы которого работают по принципу FIFO (англ. «First In, First Out» = «первым пришел, первым ушел»), т.е. элементы добавляются (вносятся) в конец контейнера, но удаляются (выталкиваются) из начала контейнера. По умолчанию в очереди используется deque в качестве последовательного контейнера, но также может использоваться и list.

            - priority_queue - это тип очереди, в которой все элементы отсортированы (с помощью оператора сравнения <). При добавлении элемента, он автоматически сортируется. Элемент с наивысшим приоритетом (самый большой элемент) находится в самом начале очереди с приоритетом, также, как и удаление элементов выполняется с самого начала очереди с приоритетом.

    - Алгоритмы;
        - min_element() - поиск минимального значения в контейнере. Возвращает итератор.
        - max_element() - поиск максимального значения в контейнере. Возвращает итератор.
        - find() - поиск нужного элемента по значению в контейнере. Возвращает итератор.
        - list::insert()
        - sort()
        - reverse()
        -
    - Приведение типов:
        - сonst_cast<>() - 

        - static_cast<>() - Преобразованием (без проверки в run-time) занимается static_cast<>(). Static_cast так же корректно работает при виртуальном наследовании.

        - dynamic_cast<>() - это безопасное приведение по иерархии наследования, в том числе и для виртуального наследования. Проводит преобразование типа, предварительно убедившись (с помощью RTTI), что объект expression_from в действительности является объектом типа type_to. Если нет: для указателей возвращает NULL. Dynamic_cast может работать только с полиморфными иерархиями.

        - reinterpret_cast<>() - результат не гарантирован, проверки не осуществляются. Ограничения на expression_from: порядковый тип (логический, символьный, целый, перечисляемый), указатель, ссылка. Ограничения на type_to: для порядкового типа или указателя — порядковый тип или указатель. Для ссылки — ссылка. Reinterpret_cast<>() вообще ничего не преобразует. Он просто заставляет компилятор считать объект имеющим иной тип.

    - Многопоточность:
        - atomic - это способ синхронизации данных между потоками так что бы к данным в памяти мог обращаться одновременно только один поток. Атомики позволяют реализововать атомарные операции. С помощью atomiс можно создать переменную с любым типом данных к которой будет одновременно обращаться только один поток. Тип atomic так же имеет методы для арифметических операций с данными.

        - mutex - способ синхронизации выполнения операций в програме методом создания секций в коде которые будут одновременно выполняться лишь одним потоком. В основном под капотом релизован на atomic.

        - conditions_variable - 

        - thread
        - future
        - promise
        - packaged_task

    -  Указатели: