 - Malloc просто выделяет память, если malloc не сможет выделить память, он возвращает нулевой указатель. 
 - New выделяет память, а так же вызвает конструктор у обьекта класса, если new не смог выделить память, он бросает исключение bad_alloc.
 - mutable нужен для указания того, что данная переменная ( mutable int someVar ) может изменяться даже в константных методах.
 - volatile - команда компилятору что переменная ( volatile int someVar ) может изменяться в любой runtime момент и компилятор не имеет права её с оптимизировать и потереть в ней значения.
 - implicit - исключаеть не явное преобразование конструктора под другой тип данных.

 - Наследование:
 	- при :public наследовании, то ничего не меняется
 	- при :private наследовании, то protected и public становятся private
 	- при :protected наследовании, то public становятся protected

 - STL:
    - Контейнеры:
        - Последовательные: 
            - vector - это динамический массив, способный увеличиваться по мере необходимости для содержания всех своих элементов. Класс vector обеспечивает произвольный доступ к своим элементам через оператор индексации [], а также поддерживает добавление и удаление элементов.

            - deque - это двусторонняя очередь, реализованная в виде динамического массива, который может расти с обоих концов.

            - array - это массив чего угодно, создание массива требует строгого обявления размера массива.

            - list - это двусвязный список, каждый элемент которого содержит 2 указателя: один указывает на следующий элемент списка, а другой — на предыдущий элемент списка. List предоставляет доступ только к началу и к концу списка — произвольный доступ запрещен. Преимуществом двусвязного списка является то, что добавление элементов происходит очень быстро. Обычно для перебора элементов двусвязного списка используются итераторы.

            - forward_list - это односвязный список
            - basic_string - это массив символов c помощью которого можно хранить любых видов символы. std::string - это typedef на basic_string<char>

        - Ассоциативные:
            - set - это контейнер, в котором хранятся только уникальные элементы, и повторения запрещены. Элементы сортируются в соответствии с их значениями.

            - multiset - это set, но в котором допускаются повторяющиеся элементы.

            - map - это set, в котором каждый элемент является парой «ключ-значение». «Ключ» используется для сортировки и индексации данных и должен быть уникальным, а «значение» — это фактические данные. Реализован на основании красно-черного дерева.

            - multimap - это map, который допускает дублирование ключей. Все ключи отсортированы в порядке возрастания, и вы можете посмотреть значение по ключу.

            - unordored_map - это map у которого ввиде уникального ключа используется хеш-сума. Ключи храняться в хаотичном порядке.
            
            - unordered_set - это set у которого ввиде уникального ключа используется хеш-сума. Ключи храняться в хаотичном порядке.

        - Адаптеры:
            - stack - это контейнерный класс, элементы которого работают по принципу LIFO (англ. «Last In, First Out» = «последним пришел, первым ушел»), т.е. элементы добавляются (вносятся) в конец контейнера и удаляются (выталкиваются) оттуда же (из конца контейнера). Обычно в стеках используется deque в качестве последовательного контейнера по умолчанию (что немного странно, поскольку vector был бы более подходящим вариантом), но вы также можете использовать vector или list.

            - queue - это контейнерный класс, элементы которого работают по принципу FIFO (англ. «First In, First Out» = «первым пришел, первым ушел»), т.е. элементы добавляются (вносятся) в конец контейнера, но удаляются (выталкиваются) из начала контейнера. По умолчанию в очереди используется deque в качестве последовательного контейнера, но также может использоваться и list.

            - priority_queue - это тип очереди, в которой все элементы отсортированы (с помощью оператора сравнения <). При добавлении элемента, он автоматически сортируется. Элемент с наивысшим приоритетом (самый большой элемент) находится в самом начале очереди с приоритетом, также, как и удаление элементов выполняется с самого начала очереди с приоритетом.

    - Алгоритмы;
        - min_element() - поиск минимального значения в контейнере. Возвращает итератор.
        - max_element() - поиск максимального значения в контейнере. Возвращает итератор.
        - find() - поиск нужного элемента по значению в контейнере. Возвращает итератор.
        - list::insert()
        - sort()
        - reverse()
        - count (It beg, It end, const T& v) – подсчет элементов со значением равным v;
        - count_if (It beg, It end, UPredicate op) – подсчет элементов для которых op(el) == true;
        - equal (It1 beg, It1 end, It2 cBeg) – истина, если два диапазона равны;
        - equal (It1 beg, It1 end, It2 cBeg [, BPredicate op]) – проверка эквивалентности двух диапазонов (очень важно не путать понятие эквивалентности и равенства – это не одно и то же!!!);
        - lexicographical_compare (It1 beg1, It1 end1, It2 beg2, It2 end2 [, BPredicate op]) – лексикографическое сравнение двух последовательностей;

        - find (It beg, It end, const T& v) – поиск первого элемента со значением v;
        - find_if (It beg, It end, UPredicate op) – поиск первого элемента для которого унарная операция op == true;
        - min_element (It beg, It end) – поиск минимального элемента последовательности;
        - min_element (It beg, It end, BPredicate op) – поиск минимального элемента для которых операция op == true;
        - max_element (It beg, It end) – поиск максимального элемента последовательности;
        - max_element (It beg, It end, BPredicate op) – поиск максимального элемента для которых операция op == true;
        - search_n (It beg, It end, Size cnt, const T& v) – поиск вхождение последовательности из cnt элементов равных v;
        - search_n (It beg, It end, Size cnt, const T& v, BPredicate op) – поиск вхождение последовательности из cnt элементов равных v и для которых операция op == true;
        - search (FIt beg, FIt end, FIt2 sBeg, FIt2 sEnd) – поиск первого вхождения последовательности элементов заданной [sbeg;sEnd);
        - search (FIt1 beg, FIt1 end, FIt2 sBeg, FIt2 sEnd, BPredicate op) – поиск первого вхождения последовательности элементов указанной [sbeg;sEnd) и с op == true;
        - find_end (FIt beg, FIt end, FIt sBeg, FIt sEnd) – поиск последнего вхождения последовательности заданной [sBeg; sEnd);
        - find_end (FIt beg, FIt end, FIt sBeg, FIt sEnd, BPredicate op) – поиск последнего вхождения последовательности указанной [sBeg; sEnd) и с op == true;
        - find_first_of (FIt1 beg, FIt1 end, FIt2 sBeg, FIt2 sEnd) – поиск первого элемента входящего также в диапазон [sBeg; sEnd);
        - find_first_of (FIt1 beg, FIt1 end, FIt2 sBeg, FIt2 sEnd, BPredicate op) – поиск первого элемента входящего также в диапазон [sBeg; sEnd), с использование предиката;
        - adjacent_find (It beg, It end) – поиск первого элемента, равного следующему;
        - adjacent_find_if (It beg, It end, BPredicate op) – поиск первого элемента, равного следующему, с использованием предиката;
        - mismatch (It1 beg, It1 end, It2 cBeg) – ищет первое несовпадение между двумя последовательностями;
        - mismatch (It1 beg, It1 end, It2 cBeg, BPredicate op) – ищет первое несовпадение между двумя последовательностями, с использованием предиката.

        - copy (It sBeg, It sEnd, OIt dBeg) – копирование последовательности;
        - copy_backward (BIt1 sBeg, BIt1 sEnd, BIt2 dEnd) – обратное копирование (в итоге будет обратный порядок следования элементов);
        - fill (FIt beg, FIt end, const T& v) – заполнение интервала указанным значением v;
        - fill_n (OIt beg, Size n, const T& v) – аналогично, заполняет интервал указанным значением;
        - generate (FIt beg, FIt end, Func op) – заполнить интервал значениями сгенерированными функцией op;
        - generate_n (OIt beg, Size n, Func op) – аналогично;
        - replace(FIt beg, FIt end, const T& v, const T& rv) – заменить в последовательности значения v на rv;
        - replace_if (FIt beg, FIt end, UPredicate op, const T& rv) – заменить в последовательности на rv все элементы для которых op(el) истина;
        - replace_copy (It sBeg, It sEnd, OIt dBeg, const T& v, const T& rv) – заменить и скопировать;
        - replace_copy_if (It sBeg, It sEnd, OIt dBeg, UPredicate op, const T& rv) – заменить на rv все элементы для которых op(el) истина и скопировать;
        - transform (It sBeg, It sEnd, OIt dBeg, UnaryF op) – копирование (запись) результатов применения op(el);
        - transform (It sBeg, It sEnd,It2 sBeg2, OIt dBeg, BinaryF op) – копирование результатов применения op(el1,el2), где el1 и el2 соответствующие элементы двух исходных последовательностей sBeg и Sbeg2;
        - swap_ranges (FIt1 beg1, FIt1 end1, FIt2 beg2) – обменять соответствующие элементы двух последовательностей.
        
    - Приведение типов:
        - сonst_cast<>() - 

        - static_cast<>() - Преобразованием (без проверки в run-time) занимается static_cast<>(). Static_cast так же корректно работает при виртуальном наследовании.

        - dynamic_cast<>() - это безопасное приведение по иерархии наследования, в том числе и для виртуального наследования. Проводит преобразование типа, предварительно убедившись (с помощью RTTI), что объект expression_from в действительности является объектом типа type_to. Если нет: для указателей возвращает NULL. Dynamic_cast может работать только с полиморфными иерархиями.

        - reinterpret_cast<>() - результат не гарантирован, проверки не осуществляются. Ограничения на expression_from: порядковый тип (логический, символьный, целый, перечисляемый), указатель, ссылка. Ограничения на type_to: для порядкового типа или указателя — порядковый тип или указатель. Для ссылки — ссылка. Reinterpret_cast<>() вообще ничего не преобразует. Он просто заставляет компилятор считать объект имеющим иной тип.

    - Многопоточность:
        - atomic - это способ синхронизации данных между потоками так что бы к данным в памяти мог обращаться одновременно только один поток. Атомики позволяют реализововать атомарные операции. С помощью atomiс можно создать переменную с любым типом данных к которой будет одновременно обращаться только один поток. Тип atomic так же имеет методы для арифметических операций с данными.

        - mutex - способ синхронизации выполнения операций в програме методом создания секций в коде которые будут одновременно выполняться лишь одним потоком. В основном под капотом релизован на atomic.

        - conditions_variable - 

        - thread
        - future
        - promise
        - packaged_task

    - Указатели:
    
    - Под капотом С++:
        - Регистры в x86-64
            - 16 регистров общего назначения: rax, rbx, rcx, rdx, rbp, rsi, rdi, rsp а также r8-r15. Размер каждого из них равен 64 битам (8 байтам). Для доступа к младшим 32 битам (4 байтам) используется префикс e вместо r (rax → eax). Поддерживают только не векторные целочисленные операции.

            - rip (instruction pointer) указывает на инструкцию, которая будет исполнена следующей. Различные константные данные, лежащие в разделе памяти с инструкциями, могут считываться по смещению относительно rip.

            - rsp (stack pointer) указывает на последний элемент в стеке. Стек растёт в сторону меньших адресов. Запихивание чего-то в стек уменьшает значение rsp.
            
            - 16 SSE регистров размером 128 бит: xmm0 - xmm15. Если поддерживается режим AVX, то они ссылаются на младшие 128 бит регистров ymm0 - ymm15 каждый из которых имеет размер 256 бит. Для векторных, или не целочисленных операций, данные необходимо предварительно загрузить в эти регистры

    - Виды памяти С++:
        - Статический — выделение памяти до начала исполнения программы. Такая память доступна на протяжении всего времени выполнения программы. Во многих языках для размещения объекта в статической памяти достаточно задекларировать его в глобальной области видимости.

        - Автоматический, также известный как «размещение на стеке», — самый основной, автоматически выделяет аргументы и локальные переменные функции, а также прочую метаинформацию при вызове функции и освобождает память при выходе из неё.
        Стек, как структура данных, работает по принципу LIFO («последним пришёл — первым ушёл»). Другими словами, добавлять и удалять значения в стеке можно только с одной и той же стороны. Автоматическая память работает именно на основе стека, чтобы вызванная из любой части программы функция не затёрла уже используемую автоматическую память, а добавила свои данные в конец стека, увеличивая его размер. При завершении этой функции её данные будут удалены с конца стека, уменьшая его размер. Длина стека останется той же, что и до вызова функции, а у вызывающей функции указатель на конец стека будет указывать на тот же адрес. Детали реализации автоматической памяти могут быть разными в зависимости от конкретной платформы. Например, кому очищать из стека метаинформацию функции и её аргументы: вызывающей функции или вызываемой? Как передавать результат: через стек или, что намного быстрее, через регистры процессора (память, расположенную прямо на кристалле процессора. В этой статье не рассматривается, т. к. в языках программирования высокого уровня зачастую нет прямого доступа к регистрам процессора). На все эти вопросы отвечает конкретная реализация calling convention — описание технических особенностей вызова подпрограмм, определяющее способы передачи параметров/результата функции и способы вызова/возврата из функции.
        Таким образом, когда одна функция вызывает другую, последняя всегда в курсе, где ей взять свои аргументы: на конце стека. Но откуда ей знать, где конец стека? В процессоре для этого есть специальный регистр, хранящий указатель на конец стека. В большинстве случаев стек расположен ближе к концу виртуальной памяти и растёт в сторону начала.
        Размер автоматической памяти, а он тоже фиксированный, определяется линковщиком (обычно — 1 мегабайт), максимальный размер зависит от конкретной системы и настроек компилятора/линковщика.
        Если приложение выйдет за максимум автоматической памяти, его там может ждать Page Fault (сигнал SIGSEGV в POSIX-совместимых системах: Mac OS X, Linux, BSD и т. д.) — ошибка сегментации, приводящая к аварийному завершению программы.

        - Динамическая — выделение памяти из ОС по требованию приложения.
        Автоматическая и статическая память выделяются единоразово перед запуском программы. При их нехватке, либо если модель LIFO не совсем подходит, используется динамическая память.
        Приложение при необходимости может запросить у ОС дополнительную память через аллокатор или напрямую через системный вызов. Пример использования динамической памяти с помощью аллокатора ниже на примере языка Си.
        После выделения памяти в распоряжение программы поступает указатель на начало выделенной памяти, который, в свою очередь, тоже должен где-то храниться: в статической, автоматической или также в динамической памяти. Для возвращения памяти обратно в аллокатор необходим только сам указатель. Попытка использования уже очищенной памяти может привести к завершению программы с сигналом SIGSEGV.
        Языки сверхвысокого уровня используют динамическую память как основную: создают все или почти все объекты в динамической памяти, а на стеке или в статической памяти держат указатели на эти объекты.
        Максимальный размер динамической памяти зависит от многих факторов: среди них ОС, процессор, аппаратная архитектура в целом, не говоря уже о самом очевидном — максимальном размере ОЗУ у конкретного устройства. Например x86_64 процессоры используют только 48 бит для адресации виртуальной памяти, что позволяет использовать до 256 ТБ памяти. В следующей статье про более низкоуровневую архитектуру памяти будет объяснено, почему не все 64 бита.