 - Malloc просто выделяет память, если malloc не сможет выделить память, он возвращает нулевой указатель. 
 - New выделяет память, а так же вызвает конструктор у обьекта класса, если new не смог выделить память, он бросает исключение bad_alloc.
 - mutable нужен для указания того, что данная переменная ( mutable int someVar ) может изменяться даже в константных методах.
 - volatile - команда компилятору что переменная ( volatile int someVar ) может изменяться в любой runtime момент и компилятор не имеет права её с оптимизировать и потереть в ней значения.
 - implicit - исключаеть не явное преобразование конструктора под другой тип данных.

 - Наследование:
 	- при :public наследовании, то ничего не меняется
 	- при :private наследовании, то protected и public становятся private
 	- при :protected наследовании, то public становятся protected

 - STL:
    - Контейнеры:
        - Последовательные: 
            - vector - это динамический массив, способный увеличиваться по мере необходимости для содержания всех своих элементов. Класс vector обеспечивает произвольный доступ к своим элементам через оператор индексации [], а также поддерживает добавление и удаление элементов.

            - deque - это двусторонняя очередь, реализованная в виде динамического массива, который может расти с обоих концов.

            - array - это массив чего угодно, создание массива требует строгого обявления размера массива.

            - list - это двусвязный список, каждый элемент которого содержит 2 указателя: один указывает на следующий элемент списка, а другой — на предыдущий элемент списка. List предоставляет доступ только к началу и к концу списка — произвольный доступ запрещен. Преимуществом двусвязного списка является то, что добавление элементов происходит очень быстро. Обычно для перебора элементов двусвязного списка используются итераторы.

            - forward_list - это односвязный список
            - basic_string - это массив символов c помощью которого можно хранить любых видов символы. std::string - это typedef на basic_string<char>

        - Ассоциативные:
            - set - это контейнер, в котором хранятся только уникальные элементы, и повторения запрещены. Элементы сортируются в соответствии с их значениями.

            - multiset - это set, но в котором допускаются повторяющиеся элементы.

            - map - это set, в котором каждый элемент является парой «ключ-значение». «Ключ» используется для сортировки и индексации данных и должен быть уникальным, а «значение» — это фактические данные. Реализован на основании красно-черного дерева.

            - multimap - это map, который допускает дублирование ключей. Все ключи отсортированы в порядке возрастания, и вы можете посмотреть значение по ключу.

            - unordored_map - это map у которого ввиде уникального ключа используется хеш-сума. Ключи храняться в хаотичном порядке.
            
            - unordered_set - это set у которого ввиде уникального ключа используется хеш-сума. Ключи храняться в хаотичном порядке.

        - Адаптеры:
            - stack - это контейнерный класс, элементы которого работают по принципу LIFO (англ. «Last In, First Out» = «последним пришел, первым ушел»), т.е. элементы добавляются (вносятся) в конец контейнера и удаляются (выталкиваются) оттуда же (из конца контейнера). Обычно в стеках используется deque в качестве последовательного контейнера по умолчанию (что немного странно, поскольку vector был бы более подходящим вариантом), но вы также можете использовать vector или list.

            - queue - это контейнерный класс, элементы которого работают по принципу FIFO (англ. «First In, First Out» = «первым пришел, первым ушел»), т.е. элементы добавляются (вносятся) в конец контейнера, но удаляются (выталкиваются) из начала контейнера. По умолчанию в очереди используется deque в качестве последовательного контейнера, но также может использоваться и list.

            - priority_queue - это тип очереди, в которой все элементы отсортированы (с помощью оператора сравнения <). При добавлении элемента, он автоматически сортируется. Элемент с наивысшим приоритетом (самый большой элемент) находится в самом начале очереди с приоритетом, также, как и удаление элементов выполняется с самого начала очереди с приоритетом.

    - Алгоритмы;
        - min_element() - поиск минимального значения в контейнере. Возвращает итератор.
        - max_element() - поиск максимального значения в контейнере. Возвращает итератор.
        - find() - поиск нужного элемента по значению в контейнере. Возвращает итератор.
        - list::insert()
        - sort()
        - reverse()
        - count (It beg, It end, const T& v) – подсчет элементов со значением равным v;
        - count_if (It beg, It end, UPredicate op) – подсчет элементов для которых op(el) == true;
        - equal (It1 beg, It1 end, It2 cBeg) – истина, если два диапазона равны;
        - equal (It1 beg, It1 end, It2 cBeg [, BPredicate op]) – проверка эквивалентности двух диапазонов (очень важно не путать понятие эквивалентности и равенства – это не одно и то же!!!);
        - lexicographical_compare (It1 beg1, It1 end1, It2 beg2, It2 end2 [, BPredicate op]) – лексикографическое сравнение двух последовательностей;

        - find (It beg, It end, const T& v) – поиск первого элемента со значением v;
        - find_if (It beg, It end, UPredicate op) – поиск первого элемента для которого унарная операция op == true;
        - min_element (It beg, It end) – поиск минимального элемента последовательности;
        - min_element (It beg, It end, BPredicate op) – поиск минимального элемента для которых операция op == true;
        - max_element (It beg, It end) – поиск максимального элемента последовательности;
        - max_element (It beg, It end, BPredicate op) – поиск максимального элемента для которых операция op == true;
        - search_n (It beg, It end, Size cnt, const T& v) – поиск вхождение последовательности из cnt элементов равных v;
        - search_n (It beg, It end, Size cnt, const T& v, BPredicate op) – поиск вхождение последовательности из cnt элементов равных v и для которых операция op == true;
        - search (FIt beg, FIt end, FIt2 sBeg, FIt2 sEnd) – поиск первого вхождения последовательности элементов заданной [sbeg;sEnd);
        - search (FIt1 beg, FIt1 end, FIt2 sBeg, FIt2 sEnd, BPredicate op) – поиск первого вхождения последовательности элементов указанной [sbeg;sEnd) и с op == true;
        - find_end (FIt beg, FIt end, FIt sBeg, FIt sEnd) – поиск последнего вхождения последовательности заданной [sBeg; sEnd);
        - find_end (FIt beg, FIt end, FIt sBeg, FIt sEnd, BPredicate op) – поиск последнего вхождения последовательности указанной [sBeg; sEnd) и с op == true;
        - find_first_of (FIt1 beg, FIt1 end, FIt2 sBeg, FIt2 sEnd) – поиск первого элемента входящего также в диапазон [sBeg; sEnd);
        - find_first_of (FIt1 beg, FIt1 end, FIt2 sBeg, FIt2 sEnd, BPredicate op) – поиск первого элемента входящего также в диапазон [sBeg; sEnd), с использование предиката;
        - adjacent_find (It beg, It end) – поиск первого элемента, равного следующему;
        - adjacent_find_if (It beg, It end, BPredicate op) – поиск первого элемента, равного следующему, с использованием предиката;
        - mismatch (It1 beg, It1 end, It2 cBeg) – ищет первое несовпадение между двумя последовательностями;
        - mismatch (It1 beg, It1 end, It2 cBeg, BPredicate op) – ищет первое несовпадение между двумя последовательностями, с использованием предиката.

        - copy (It sBeg, It sEnd, OIt dBeg) – копирование последовательности;
        - copy_backward (BIt1 sBeg, BIt1 sEnd, BIt2 dEnd) – обратное копирование (в итоге будет обратный порядок следования элементов);
        - fill (FIt beg, FIt end, const T& v) – заполнение интервала указанным значением v;
        - fill_n (OIt beg, Size n, const T& v) – аналогично, заполняет интервал указанным значением;
        - generate (FIt beg, FIt end, Func op) – заполнить интервал значениями сгенерированными функцией op;
        - generate_n (OIt beg, Size n, Func op) – аналогично;
        - replace(FIt beg, FIt end, const T& v, const T& rv) – заменить в последовательности значения v на rv;
        - replace_if (FIt beg, FIt end, UPredicate op, const T& rv) – заменить в последовательности на rv все элементы для которых op(el) истина;
        - replace_copy (It sBeg, It sEnd, OIt dBeg, const T& v, const T& rv) – заменить и скопировать;
        - replace_copy_if (It sBeg, It sEnd, OIt dBeg, UPredicate op, const T& rv) – заменить на rv все элементы для которых op(el) истина и скопировать;
        - transform (It sBeg, It sEnd, OIt dBeg, UnaryF op) – копирование (запись) результатов применения op(el);
        - transform (It sBeg, It sEnd,It2 sBeg2, OIt dBeg, BinaryF op) – копирование результатов применения op(el1,el2), где el1 и el2 соответствующие элементы двух исходных последовательностей sBeg и Sbeg2;
        - swap_ranges (FIt1 beg1, FIt1 end1, FIt2 beg2) – обменять соответствующие элементы двух последовательностей.
        
    - Приведение типов:
        - сonst_cast<>() - 

        - static_cast<>() - Преобразованием (без проверки в run-time) занимается static_cast<>(). Static_cast так же корректно работает при виртуальном наследовании.

        - dynamic_cast<>() - это безопасное приведение по иерархии наследования, в том числе и для виртуального наследования. Проводит преобразование типа, предварительно убедившись (с помощью RTTI), что объект expression_from в действительности является объектом типа type_to. Если нет: для указателей возвращает NULL. Dynamic_cast может работать только с полиморфными иерархиями.

        - reinterpret_cast<>() - результат не гарантирован, проверки не осуществляются. Ограничения на expression_from: порядковый тип (логический, символьный, целый, перечисляемый), указатель, ссылка. Ограничения на type_to: для порядкового типа или указателя — порядковый тип или указатель. Для ссылки — ссылка. Reinterpret_cast<>() вообще ничего не преобразует. Он просто заставляет компилятор считать объект имеющим иной тип.

    - Многопоточность:
        - atomic - это способ синхронизации данных между потоками так что бы к данным в памяти мог обращаться одновременно только один поток. Атомики позволяют реализововать атомарные операции. С помощью atomiс можно создать переменную с любым типом данных к которой будет одновременно обращаться только один поток. Тип atomic так же имеет методы для арифметических операций с данными.

        - mutex - способ синхронизации выполнения операций в програме методом создания секций в коде которые будут одновременно выполняться лишь одним потоком. В основном под капотом релизован на atomic.

        - conditions_variable - 

        - thread
        - future
        - promise
        - packaged_task

    -  Указатели: