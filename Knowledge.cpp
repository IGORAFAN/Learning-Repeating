//Словарь
while    - период времени
Variable - переменная
Value    - значение
Integer  - целочисленная
loopCount- количестао проходов
break    - перерыв
case     - место что бы что то положить
array    - Массив
switch   - Переключатель 
void     - свободный, пустота.
derivation - вывод, дифференцирование, происхождение
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if (i++ == contacts.end() - 1) // пару строк изнасиловало мозг 20мин.
    i = contacts.begin();
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//обмен двух переменных без использования третей переменной
a = 3; b = 5;
a = a + b; //8 = 3 + 5
b = a - b; //3 = 8 - 5
a = a - b; //5 = 8 - 3
ИЛИ
a *= b; //15 = 3 * 5
b /= a; // 3 = 5 / 15
a /= b; // 5 =15 / 3
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Полезные функции
cin.get() получает символ из потока данных и возвращает его в переменную.
cin.clear() восстанавливает поток, если что-то пошло не так. Например хотел получить число, а получил букву. Поток впадает в ступор Чтобы восстановить работу потока вы вызываете cin.clear().
pow(a,b) возводит в степень b число a.
сin.getline(cin, name) вводит строку символов через cin.
system("cls") очищает экран.
sizeof(a) показывает размер в оперативке занимаемый переменной.
//Термины
Переменная — это область памяти, к которой мы обращаемся за находящимися там данными, используя идентификатор(в данном случае, имя переменной).
При этом у этой помеченной именем области есть еще и адрес, выраженный числом и понятный компьютерной системе.Этот адрес можно получить и записать в особую переменную.
Переменную, содержащую адрес области памяти, называют указателем.
Когда мы меняем значение обычной переменной, то, можно сказать, просто удаляем из конкретной области памяти данные и записываем туда новые.
Когда мы меняем значение переменной - указателя, то начинаем работать с совершенно иным участком памяти, т.к.меняем содержащийся в ней адрес.
Тема указателей тесно связана с темой динамических типов данных.Когда программа компилируется,
то под объявленные переменные так или иначе(в зависимости от того, где они были объявлены) выделяются участки памяти.Потом размер этих участков не меняется,
может меняться только их содержимое(значения или данные). Однако именно с помощью указателей можно захватывать и освобождать новые участки памяти уже в процессе выполнения программы.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Классы в программировании состоят из свойств и методов.
Свойства — это любые данные, которыми можно характеризовать объект класса.
В нашем случае, объектом класса является студент, а его свойствами — имя, фамилия, оценки и средний балл.
У каждого студента есть имя — name и фамилия last_name.Также, у него есть промежуточные оценки за весь семестр.
Эти оценки мы будем записывать в целочисленный массив из пяти элементов.
После того, как все пять оценок будут проставлены, определим средний балл успеваемости студента за весь семестр — свойство average_ball.
Методы — это функции, которые могут выполнять какие - либо действия над данными(свойствами) класса.

Методы класса — это его функции.
Свойства класса — его переменные.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
При создании статического объекта, для доступа к его методам и свойствам, используют операция прямого обращения — «.»(символ точки).
Если же память для объекта выделяется посредством указателя, то для доступа к его методам и свойствам используется оператор косвенного обращения — «->».
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Ключевое слово auto указывает компилятору использовать выражение инициализации объявленной переменной, или параметр лямбда-выражения, чтобы вывести ее тип.
Ключевое слово auto рекомендуется использовать в большинстве ситуаций (кроме тех, когда требуется преобразование), поскольку оно обладает рядом преимуществ:
Надежность. Если тип выражения изменился (в том числе если изменен возвращаемый тип функции), это не влияет на его работу.
Эффективность. Преобразование гарантированно не будет выполнено.
Удобство использования. Можно не беспокоиться об опечатках и ошибках.
Эффективность. Быстрое написание кода.
Случаи преобразования, для которых не подходит ключевое слово auto:
Если необходимо получить конкретный тип.
Вспомогательные типы шаблона выражения (например, (valarray+valarray) или списки инициализаторов), хотя и в редких случаях, если вы намереваетесь написать строку кода auto x = { 1 }; и ожидаете получить значение типа int.
Чтобы использовать ключевое слово auto, укажите его вместо типа для определения переменной, а затем задайте выражение инициализации. Кроме того, ключевое слово auto можно изменить с помощью спецификаторов и деклараторов,
например const, volatile, указателя (*), ссылки (&) и ссылки rvalue (&&). Компилятор вычисляет выражение инициализации, а затем использует эти сведения, чтобы вывести тип переменной.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//как запретить конструкторы копирования и присваивания
struct sData
{
	sData(){}// конструктор по умолчанию
	sData(sData&) = delete;//запрещаем копирование в конструкторе
	sData &operator =(sData) = delete;//запрещаем присваивание в конструкторе
};
int main(int argc, char const *argv[])
{
	sData s;//создаём экземпляр, конструктор по умолчанию
	sData s1 = s;//создаём второй экземпляр, вызываем конструктор копирования
	s1 = s;//вызываем конструктор присваивания
	return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//как запретить перегрузку функций с ненужными типами
void f(int){
	cout << "int" <<endl;
}
void f(long){
    cout << "long" <<endl;
}
void f(long long){
	cout << "long long" <<endl;
}
void f(char) = delete;
void f(bool) = delete;
void f(double) = delete;

int main(int argc, char const *argv[]){
	char v = 'a';
	
	////....a

	f(1);   //ok
	f(1L);  //ok
	f(1LL); //ok
	f(v);   //no
	f(trur);//no
	f(3.5f);//no

	return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//Проверка на ввод
if (cin.fail()) {
	cout << "Неверный ввод!!!" << endl;
	cin.clear();//Восстановили поток
	cin.ignore(cin.rdbuf()->in_avail());//Почистили поток
}
//Проверка на ввод
	for (;;) {
		cout << "\nВведите сторону a>";
		cin >> a; //Ввод данных
		if (!cin) {
			cout << "Не корректно введены данные\n";
			cin.clear();
			while (cin.get() != '\n');
		}
		else break;
	}
	for (;;) {
		cout << "Введите сторону b>";
		cin >> b; //Ввод данных
		if (!cin) {
			cout << "Не корректно введены данные\n";
			cin.clear();
			while (cin.get() != '\n');
		}
		else break;
	}
	for (;;) {
		cout << "Введите сторону c>";
		cin >> c; //Ввод данных
		if (!cin) {
			cout << "Не корректно введены данные\n";
			cin.clear();
			while (cin.get() != '\n');
		}
		else break;
	}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Размеры переменных в С++
data type          byte         max value 
bool               =  1         255.00
char               =  1         255.00
short int          =  2         32767.00
unsigned short int =  2         65535.00
int                =  4         2147483647.00
unsigned int       =  4         4294967295.00
long int           =  4         2147483647.00
unsigned long int  =  4         4294967295.00
float              =  4         2147483647.00
long float         =  8         9223372036854775800.00
double             =  8         9223372036854775800.00  

int    - n  - 1;             //Целочисленная.
float  - f  - 1.0f;          //Действительное чисто.
double - d  - 1.0;           //Действительное чисто (розширеная версия "float").
char   - c  - "с";           //Симолы.
long   - l  - loL;          //Целочисленная (розширеная версия "int").
string - sz - "Hello world"; //набор символов или даже целое предложение. asm	auto	bool	break	case
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Ключевые слова С++
continue, default, delete, do, double dynamic_cast, else, enum, explicit, export extern, false, float, for, friend, goto, goto, inline, int, long,mutable, namespace, new, operator, private, protected,
public, register, reinterpret_cast, return short,signed, sizeof, static, static_cast short, short, signed, sizeof, static, static_cast struct, switch, template, this, throw, typedef, true, try,
typeid, typename union, void union, using, virtual, void

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//операторы
ОПЕРАТОР:             ЗНАЧЕНИЕ:
==                    Равенство; истинно, когда значение левого аргумента совпадает со значением правого 
!=                    Неравенство; противоположно равенству 
>,<                   Больше, меньше; истинно, когда значение левого выражения больше (или меньше) значения правого
>=,<-                 Больше или равно, меньше или равно; истинно, если истиной является > или == (соответственно < или==)
&&                    И; истинно, если аргументы и слева и справа являются истиной
||                    ИЛИ; истинно, если или левый, или правый аргумент являются истиной 
!                     НЕ; истинно, если его аргумент принимает ложное значение

ОПЕРАТОР:             ЗНАЧЕНИЕ:
~                     Каждый бит меняет свое значение на противоположное: 0 заменяется 1,1— нулем 
&                     Битовое И: поочередно выполняет операцию И с парами битов левого и правого аргумента 
I                     Битовое ИЛИ 
^                     Битовое исключающее ИЛИ
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Таблица истинности для &&
true  && false: 0
false && true:  0
true  && true:  1
false && false: 0
//Таблица истинности для ||
true  || false: 1
false || true:  1
true  || true:  1
false || false: 0
//Таблица истинности для !
!true:  0
!false: 1
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Приоритеты
Приоритеты:                    ОПЕРАТОРЫ:                  ЗНАЧЕНИЕ:
-1-                           + (унарный)                  Реально ничего не изменяет
-1-                           - (унарный)                  Возвращает противоположное по знаку, равное по модулю значение 
-2-                          ++ (унарный)                  Оператор инкремента, увеличивает значение аргумента на 1
-2-                           — (унарный)                  Оператор декремента, уменьшает значение аргумента на 1
-3-                           * (бинарный)                 Умножение
-3-                           / (бинарный)                 Деление
-3                            % (бинарный)                 Остаток (деление на модуль)
-4-                           + (бинарный)                 Сложение                                                       
-4-                           - (бинарный)                 Вычисление                                                     
-5-              =(*=1Р6=|+=1-= (специальные)              Операторы присвоений
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ofstream // Класс для записи в файлы
ifstream // Класс для чтения из файла

//Режимы открытия файлов устанавливают характер использования файлов. 
//Для установки режима в классе ios_base предусмотрены константы, которые определяют режим открытия файлов
Константа			Описание
ios_base::in		открыть файл для чтения
ios_base::out		открыть файл для записи
ios_base::ate		при открытии переместить указатель в конец файла
ios_base::app		открыть файл для записи в конец файла
ios_base::trunc		удалить содержимое файла, если он существует
ios_base::binary	открытие файла в двоичном режиме

ofstream fout("cppstudio.txt", ios_base::app); // открываем файл для добавления информации к концу файла
	fout.open("cppstudio.txt", ios_base::app); // открываем файл для добавления информации к концу файла
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Полезное с переменными
int varl = 10;                                                 
int var2 = -varl; //изменение знака аргумента на противоположный

nVariable += 2;  // Смысл этой записи таков: "значение переменной nVariable увеличено на 2"

int var = 10;    //Инициализация переменной                       
 ++var/var++;    //Ее увеличение; значение переменной равно 11

//Преобразование
int i = 10;
double d;

d = (double)i; // преобразуем переменную типа integer в тип double и присваиваем значение переменной d типа double.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Указатели 
double  a = 23.5; 	//создадим простую переменную со значением 23.5 
double *ptr = &d;   //создатим указатель и ему присвоим в значение адресс переменной d и он будет хранить адресс той самой перемменной d,
					//а адресс самого указателя будет другой и храниться будет в другом месте в оперативке
int &link = a;		//так мы создали ссылку на переменную а, по сути ссылка - это псевдоним имени переменной.

*    // так мы указываем что это не просто переменная,а указатель котороый может хранить адресс переменной которую мы ему присвоим как своё значение 
&a   // так мы просим при выводе через cout показать нам адрес какой то переменной //знак Амперсанда
ptr  // так мы при выводе через cout увидем его значение в виде адресса в оперативке той самой переменной которою мы присвоили указателю
*ptr // так мы просим при выводе через cout, показать значения той переменной, по адресу который присвоили указателю, значения узнаются когда cout посмотрит по адресу какие там значения в ячейках памяти
&ptr // так мы просим при выводе через cout показать нам адрес самого указателя.

a	 - 23.5
&a   - 0117F978
ptr  - 0117F978
*ptr - 23.5
&ptr - 0117F96C

//Когда мы оперируем данными, то используем знак *
//Когда мы оперируем адресами, то используем знак & 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Используется в функции main() в самих акгументах для консоли
char* string = "stroka slova iz simvolow"
char** point2s = &string;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Пример Динамического выделения диапазона памяти под размер массива определённый пользователем
int n;								// создание переменной
cout << "Введите размер массива";   // запрос
cin >> n ;							// ввод значения в переменную

int* p = new int[n];				// создание указателя который получает в своё значение адрес массива с розмером n выделеный оператором new,
	// (при выделении он обязан вернуть адрес выделенного ним массива!).

delete [] p; // динамическое удаление массива( по виду кажется что не понятно какого, но на самом деле) по адресу который лежит в значении указателя с именем p.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Динамическое выделение памяти под переменную
 int main(){
    int *a = new int; 	 // Объявление указателя для переменной типа int
    int *b = new int(5); // Инициализация указателя, имя не нужно ставить (имя - это начальный адрес области памяти выделенный под переменную и этот адресс передаётся указателю) 
    //любое действие с переменной делается через указатель.

    *a = 10; // присваиваем переменной через указатель значения
    *b = *a + *b; // работаем с переменными через указатели

    cout << "b is " << *b << endl; // выводим значения переменной через указатель, используем *

    delete b; // удаляем область переменной через указатель
    delete a; // удаляем область переменной через указатель

    return 0;
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Пример для показания - как можно использовать ссылки и указатели в аргументах функций,
//что бы изменять значение в главной фукции Main без применения оператора return.
#include <iostream>
using namespace std;

//Реализация Функций
int mul(int b) { //прием аргумента A
	b *= 2;
	return b; //для конечного изменения значения, необходимо  вернуть аргумент
}
void div(int &b) { //прием ссылки на аргумент A
	b /= 2;
	//для конечного изменения значения, возвращать аргумент не требуется
}
void sqr(int *b) { //прием указателя с адресом на значение аргумента A
	*b *= *b;
	//для конечного изменения значения, возвращать аргумент не требуется
}
//Главная Функция
int main(void)
{
	int a = 6;
	mul(a); //передача аргумента (копии) 
	cout << "6 * 2 = " << a << endl;

	a = 6;
	div(a); //передача аргумента (функция принемает ссылку на аргумент)
	cout << "6 / 2 = " << a << endl;

	a = 6;
	sqr(&a);// передача указателя с адресом на значение аргумента
	cout << "6 * 6 = " << a << endl;

	system("pause");
	return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ -
//Пример Роботы с файлами с помощю обьеков класов ofstream/ifstream и их методами
#include <iostream>
#include <fstream> // работа с файлами
#include <string>

using namespace std;

int main(){
	setlocale(LC_ALL, "rus");
	// Создаём обьект от класса ofstream
	ofstream fileworkOut;
	// Cвязываем объект с файлом, при этом файл открываем в режиме записи, предварительно удаляя все данные из него
	fileworkOut.open("Data_Types.txt", ios_base::out | ios_base::trunc);
	// Eсли файл небыл открыт
	if (!fileworkOut.is_open()){
		// Напечатать соответствующее сообщение
		cout << "Файл не может быть открыт или создан\n";
		// Выполнить выход из программы
		return 1;
	}else {
		fileworkOut << "data type      "<< "\t\tbyte"<< endl // заголовки столбцов
			<< "bool\t\t\t= "  << sizeof(bool) << endl
			<< "char\t\t\t= "  << sizeof(char) << endl
			<< "short int\t\t= "		<< sizeof(short int) << endl
			<< "unsigned short int\t= " << sizeof(unsigned short int) << endl
			<< "int\t\t\t= "   << sizeof(int) << endl
			<< "unsigned int\t\t= "		<< sizeof(unsigned int) << endl
			<< "long int\t\t= "<< sizeof(long int) << endl
			<< "unsigned long int\t= "  << sizeof(unsigned long int) << endl
			<< "float\t\t\t= " << sizeof(float) << endl
			<< "long float\t\t= " << sizeof(long float) << endl;
	}
	// Программа больше не использует файл, поэтому его нужно закрыть
	fileworkOut.close();
	cout << "Данные успешно записаны в файл Data_Types.txt\n" << endl;

	/////////////////////////////////////////////////////////////////////////////////////////////////////
	// Создаём обьект от класса ofstream
	ifstream fileworkIn;
	// Cвязываем объект с файлом, при этом файл открываем в режиме записи, предварительно удаляя все данные из него
	fileworkIn.open("Data_Types.txt", ios_base::in);
	const int size(1000);
	char someText[size];
	//Костыль, с помошью такой записи мы читаем весь текст из файла построчно, главное не забыть про endl.
	while (!fileworkIn.eof()){
		fileworkIn.getline(someText, size);
		cout << someText << endl;
	}
	//Закрываем файл
	fileworkIn.close();
	//Делаем проверку на открытие файла.
	if (fileworkIn.is_open()) {
		cout << "Данные успешно выведены на экран из файла Data_Types.txt\n" << endl;
	}
	system("pause");
	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Пример работы с аргументами, функциями (Массивам вообще похрен, им указатели не нужны для передачи в аргументы и изменения внутри функции)
#include <iostream>
#include <conio.h>
using namespace std;
//Превью программы
void preview() {
	cout << "Программа по перенаправлению из Одного массива Х в два други массива Y и Z" << endl;
	cout << "В массив Y перенаправляются - положительные числа, в массив Z - отрицательные" << endl << endl;
}
//Проверка Ввода
void сheckEnter(int &i) {
	//Если есть ошибка, выводим сообщение 
	if (cin.fail()) {
		cout << "Неверный ввод!!!" << endl;
		cin.clear();//Восстановили поток
		cin.ignore(cin.rdbuf()->in_avail());//Почистили поток
	}else {i++;}
}
//Ввод данных
void enter(int size, double arrXptr[]) {
	for (int i(0); i < size;) {
		cout << "Введите " << i << " элемент массива: ";
		cin >> arrXptr[i];
		сheckEnter(i);
	}
	cout << endl;
}
//Логика отсеивания чисел
void logic(int size, int &z, int &y, double arrXptr[], double arrYptr[], double arrZptr[]) {
	for (int j(0); j < size; j++) {
		if (arrXptr[j] >= 0) {
			arrYptr[y] = arrXptr[j];
			y++;
		}
		else {
			arrZptr[z] = arrXptr[j];
			z++;
		}
	}
}
//Вывод данных
void out(int size, int z, int y, double arrX[], double arrY[], double arrZ[]) {
	for (int dash(0); dash < size; dash++) {cout << "------"; }

	cout << endl << "Массив  Х: ";
	for (int i(0); i < size; i++) {cout << arrX[i] << ", "; }
	cout << endl << "Массив +Y: ";
	for (int Y(0); Y < y; Y++) {cout << arrY[Y] << ", "; }
	cout << endl << "Массив -Z: ";
	for (int Z(0); Z < z; Z++) {cout << arrZ[Z] << ", "; }
	cout << endl;

	for (int dash(0); dash < size; dash++) {cout << "------"; }
}
//Главная функция
void main(){
	setlocale(LC_ALL, "Russian");

	const int size = 10;
	int y(0), z(0);
	double arrX[size], arrY[size], arrZ[size];
	//Вызов функций
	preview();
	enter(size, arrX);
	logic(size, z, y, arrX, arrY, arrZ);
	out(size, z, y, arrX, arrY, arrZ);

	_getch();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ -
//Пример приминения дружественной функции, классов, конструкторов и деструкторов по умолчанию
#include <iostream>
#include <conio.h>
#include <string>

using namespace std;
//Cоздаём прототип класса second.
class second;
//Создаем Класс first
class first {
	//Обьявляем что функ. sum является дружественной для класса first.
	friend int sum(first first_arg, second second_arg);
public:
	//Конструктор по умолчанию
	first() {
		cout << "Введите число a: ";
		cin >> a;
	}
	//Деструктор по умолчанию
	~first() {
		cout << "Bay Bay!" << endl;
	}
private:
	int a;
};
//Создаём класс Auto
class second {
	//Обьявляем что функ. sum является дружественной для класса second.
	friend int sum(first first_arg, second second_arg);
public:
	//Конструктор по умолчанию
	second() {
		cout << "Введите число b: ";
		cin >> b;
	}
	//Деструктор по умолчанию
	~second() {
		cout << "Bay Bay!" << endl;
	}
private:
	int b;
};
//Cоздаём дружественную функцию sum которая принимает к себе в арг обьекты разных классов
int sum(first first_arg, second second_arg) {
	//Соединяем значения переменных через обьекты с помощью того что функ. дружественная и ей дан доступ к private
	return (first_arg.a + second_arg.b);
}

void main() {
	setlocale(LC_ALL, "rus");
	//Создаём обьект класса
	first first;
	//Создаём обьект класса
	second second;
	//Вызываем функ. и влаживаем обьекты
	cout << sum(first, second);

	_getch();
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Пример приминения дружественных классов
#include <iostream>
#include <conio.h>

using namespace std;
//Создаём класс Врага
class enemy {
	//Обьявляем класу врага что класс героя для него дружественный ради взаимодействея переменных
	friend class heroes;
public:
	//Конструктор по умолчанию
	enemy() {
		cout << "HP Enemy: " << healthsEnemy << endl;
		cout << "SM Enemy: " << staminaEnemy << endl;
	}
	/*void damageHp(heroes &obj_arg) {
	obj_arg.healthsHero -= 20;
	cout << "HP heroes " << obj_arg.healthsHero << endl;
	}*/
	//Деструктор по умолчанию
	~enemy() {}
private:
	//Жизни и выносливость врага
	int healthsEnemy = 100;
	int staminaEnemy = 100;
};
//Создаём класс героя
class heroes {
	//Обьявляем класу героя что класс врага для него дружественный ради взаимодействея переменных
	friend class enemy;
public:
	//Конструктор по умолчанию
	heroes() {}
	//Метод лёгкого урона
	void damageHp(enemy &obj_arg) {
		obj_arg.healthsEnemy -= 20;
		cout << endl << "Fite!!!" << endl;
		cout << "HP enemy " << obj_arg.healthsEnemy << endl;
	}
	//Метод тяжелого урона
	void damageOverHp(enemy &obj_arg) {
		obj_arg.healthsEnemy -= 80;
		cout << endl << "Fite!!!" << endl;
		cout << "HP enemy " << obj_arg.healthsEnemy << endl;
	}
	//Метод убийства врага
	void killEnemy(enemy &obj_arg) {
		obj_arg.healthsEnemy = 0;
		cout << endl << "Fite!!!" << endl;
		cout << "HP enemy " << obj_arg.healthsEnemy << endl;
	}
	//Метод лёгкого урона по выносливости
	void damageStamina(enemy &obj_arg) {
		obj_arg.staminaEnemy -= 30;
		cout << endl << "Fite!!!" << endl;
		cout << "SM enemy " << obj_arg.staminaEnemy << endl;
	}
	//Метод тяжёлого урона по выносливости
	void damageStaminaOver(enemy &obj_arg) {
		obj_arg.staminaEnemy -= 70;
		cout << endl << "Fite!!!" << endl;
		cout << "SM enemy " << obj_arg.staminaEnemy << endl;
	}
	//Проверка на жизнь
	void chekLife(enemy obj_arg) {
		if (obj_arg.healthsEnemy <= 0) {
			cout << "Enemy Die... " << endl;
		}
		else {
			cout << "Enemy still alive" << endl;
		}
	}
	//Деструктор по умолчанию
	~heroes() {}
private:
	int healthsHero = 100;
};

void main() {
	setlocale(LC_ALL, "rus");

	enemy ogr;
	heroes pipboy;

	pipboy.damageStamina(ogr);//Герой наносит урон по врагу
	pipboy.damageHp(ogr);//Герой наносит урон по врагу
	pipboy.damageStaminaOver(ogr);//Герой наносит урон по врагу
	//ogr.damageHp(pipboy);//Враг наносит урон по герою
	pipboy.chekLife(ogr);//Проверяет жизнь врага
	pipboy.damageHp(ogr);//Герой наносит урон по врагу
	pipboy.damageHp(ogr);//Герой наносит урон по врагу
	pipboy.damageHp(ogr);//Герой наносит урон по врагу
	pipboy.chekLife(ogr);//Проверяет жизнь врага
	pipboy.damageHp(ogr);//Герой наносит урон по врагу
	pipboy.chekLife(ogr);//Проверяет жизнь врага

	_getch();
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Пример передачи инфы от конструкторов дочерних классов к конструктору главного класса
#include <iostream>
#include <conio.h>

using namespace std;

class first {
private:
	int var = 0;
public:
	first(int var) {
		this->var = var;
		cout << "Variable: " << var << endl;
	}
	//void set(int var) {
	//	this->var = var;
	//}
	//void get() {
	//	cout << "Variable: " << var << endl;
	//}
	~first() {}
protected:

};

class second:public first {
private:
public:
	second(int var):first(var) {}
	~second() {}
protected:
};

class third :public first {
private:
public:
	third(int var):first(var) {}
	~third() {}
protected:
};

void main() {
	setlocale(LC_ALL, "rus");

	second objS(10);
	third objT(20);

	_getch();
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Пример наследования методов из главного класса в 2 дочерних и применение их на обьектах дочерних классов
#include <iostream>
#include <conio.h>

using namespace std;

class first {
private:
	int var = 0;
public:
	first() {}
	void set(int var) {
		this->var = var;
	}
	void get() {
		cout << "Variable: " << var << endl;
	}
	~first() {}
protected:

};

class second :public first {
private:
public:
	second() {}
	~second() {}
protected:
};

class third :public first {
private:
public:
	third() {}
	~third() {}
protected:
};

void main() {
	setlocale(LC_ALL, "rus");

	second objS;
	objS.set(20);
	objS.get();

	third objT;
	objT.set(30);
	objT.get();

	_getch();
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Пример работы конструкторов и деструкторов при полиморфизме
#include <iostream>

using namespace std;

// Базовый класс
class Base{
public:
	Base(){
		cout << "Base::ctor()" << endl;
	}
	virtual ~Base() {
		cout << "Base::dtor()" << endl;
	}
	virtual void print() = 0;
};

// Вспомогательный класс
class Object{
public:
	Object() {
		cout << "Object::ctor()" << endl;
	}
	~Object() {
		cout << "Object::dtor()" << endl;
	}
};

// Производный класс
class Derived : public Base{
public:
	Derived(){
		cout << "Derived::ctor()" << endl; 
	}
	~Derived(){
		cout << "Derived::dtor()" << endl;
	}
	void print() {}
	Object  obj;
};
int main(){
	Base * p = new Derived;
	delete p;

	system("pause");
	return 0;
}

//Base::ctor()
//Object::ctor()
//Derived::ctor()
//Derived::dtor()
//Object::dtor()
//Base::dtor()
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
В языке С++ расширены возможности структуры, если сравнивать их с языком С.
В С++ классы и структуры тесно взаимосвязаны. Фактически,за одним исключением, 
они взаимозаменяемы, по­скольку структура в С++ может включать как данные, так и код,
который может манипулировать этими данными таким же образом, как и класс.
Структуры также могут содержать конструкторы и деструкторы.
Единственное отличие между ними связано с тем, что по умолчанию члены класса имеют 
в качестве спецификатора доступа private, тогда как спецификатором доступа членов 
струк­туры служит public. Согласно формальному синтаксису С++, ключевое слово struct 
определяет тип класса. В качестве примера рассмотрим программу:

#include <iostream.h>
struct cl {
  int get_i(); // публичные
  void put_i(int j); // по умолчанию
  private:
    int i;
};
int cl::get_i() {
  return i;
}
void cl::put_i(int j) {
  i = j;
}
int main() {
  cl s;
  s.put_i(10);
  cout << s.get_i();
  return 0;
}

В этой простой программе определен тип структуры с именем cl, 
в которой функции get_i() и put_i() являются соответственно public и private.
Обратим внимание, что структура использует ключевое слово private для введения 
частных членов структуры.

Ниже приведена эквивалентная программа, использующая класс вместо структуры.

#include <iostream.h>
class cl {
  int i; // по умолчанию частный
public:
  int get_i();
  void put_i(int j);
};

int cl::get_i() {
  return i;
}

void cl::put_i(int i) {
  this->i = i;
}

int main() {
  cl s;
  s.put_i(10);
  cout << s.get_i();
  return 0;
}

В большинстве случаев программисты, работающие на языке С++, используют классы для опре­деления объектов, 
содержащих и данные и код. Они используют структуры для определения объек­тов, содержащих только данные. 
Это означает, что структуры используются обычно точно в том же стиле, что и структуры в языке С. 
Тем не менее время от времени встречается код на языке С++, который использует расширенные 
возможности структур.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Полиморфимз
class A {
public:
	virtual void f() = 0;
}

class B : A {
public:
	void f(){
		//переопределение
	}
}

class C : A {
public:
	void f(){
		//переопределение
	}
}

A * b = new B();
A * c = new C();
b->f(); // здесь будет вызываться метод класса B
c->f(); // здесь будет вызываться метод класса C

Почему следует использовать полиморфимз?
1. Пусть есть игра(starcraft, козаки, и подобные).Создается класс "базовый юнит".От него наследуются все юниты.Все созданные юниты добавляются в один большой массив(вектор, список).Когда нужно отрисовать, то просто в цикле вызываем у всех функция draw и не думаем, а кто у нас там.Каждый объект и так знает, как ему рисоваться.
2. мессенджер типа миранда или квип.Есть куча различных сервисов(аська, жаббер, мейлру).У всех есть контакт лист.Сам мессенджер ничего не знает о сервисах, он просто вызывает функции, а за счет виртуальности и полиморфизма вызываются правильные функции.При этом, если был добавлен новый сервис, то не нужно переписывать весь код, что бы он был в курсе.
Да, без полиморфизма можно обойтись и делать dispatch вручную.Нет, в 2013 году так никто не делает*, потому что изобретать велосипед всем надоело, и лучше заставить компилятор делать то, где вы вполне можете ошибиться.
Смысл полиморфизма как раз и заключается в том, что вам не нужно делать cast и знать runtime - тип объекта с потенциальной возможностью ошибиться.С полиморфизмом, вы просто вызываете метод, и отрабатывает то, что нужно, без вашего ручного управления.
Если у вас всего два - три объекта, вы можете вполне обойтись парочкой if ов, проблем нет.
Но если у вас тысячи объектов, которые приходят из других частей программы, вам придётся либо пользоваться виртуальными методами, либо перед каждым вызовом делать огромный switch, в котором вы проверяете тип объекта.
Пример: у вас есть 10 различных классов, наследованных от общего предка.У предка есть метод зафигачить(int сколькоРаз).Вам нужно для всех этих объектов вызвать зафигачить(номерОбъекта).Как это сделать ? Без полиморфизма ваш код будет выглядеть так :

for (int i = 0; i < objectPointers.size(); i++)
{
	Base* pBase = objectPointers[i];
	switch (pbase->type)
	{
	case TYPE_CLASS1:
	{
		Class1* pClass1 = static_cast<Class1*>(pBase);
		pClass1->зафигачить(i);
	}
	break;
	case TYPE_CLASS2:
	{
		Class2* pClass2 = static_cast<Class2*>(pBase);
		pClass2->зафигачить(i);
	}
	break;
	// и т. д.
	}
}

С полиморфизмом вы вполне можете обойтись таким кодом :

for (int i = 0; i < objectPointers.size(); i++)
{
	objectPointers[i]->зафигачить(i);
}

Согласитесь, легче в понимании и поддержке. :)

*за исключением редких случаев, когда пишут на самом деле на C, а не C++

//Немного теории
//Методы, которые требуют переопределения, называются абстрактными. Логично, что если класс содержит хотя бы один абстрактный метод, то он тоже является абстрактным.
//Очевидно, что обьект абстрактного класса невозможно создать, иначе он не был бы абстрактным.
//Производный класс имеет свойства и методы, принадлежащие базовому классу, и, кроме того, может иметь собственные методы и свойства.
//Метод, переопределяемый в производном классе, называется виртуальным.В базовом абстрактном классе об этом методе нет никакой информации.
//Суть абстрагирования в том, чтобы определять метод в том месте, где есть наиболее полная информация о том, как он должен работать.
--------------------------------------------------------------
//Полиморфная обвёртка функции
#include<iostream>
#include<vector>

using namespace std;

void foo(int a) {
	if (a > 10 && a < 40) {
		cout << "foo " << a << endl;
	}
}

void bar(int a) {
	if (a % 2 == 0) {
		cout << "bar " << a << endl;
	}
}

void doWork(vector<int>vectOfNumb, vector<function<void(int)>>vectOfFunc) {
	for (auto var : vectOfNumb) {
		for (auto &func : vectOfFunc) {
			func(var);
		}
	}
}

int main() {
	vector<int> vectorOfNumbers = { 2,5,7,8,0,6,13123,435,32,456,6723,452,56,645,867,34,524,12,645,435,234,6,4, 2 };
	vector<function<void(int)>> vectorOfFunc;
	vectorOfFunc.emplace_back(foo);
	vectorOfFunc.emplace_back(bar);
	doWork(vectorOfNumbers, vectorOfFunc);
	system("pause");
	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#MultiThread

#include<thead>
#include<chrono>

thead th1(someFunction); //создание потока и вписываем функцию которая будет выполнятся в новом потоке
th1.detach();//закрыть поток во время конца выполнения программы недоходя до конца выполнение потока
th1.join();//дожидатся конца роботы потока
this_thread::sleep_for(chrono::millisecond(1000));//пауза в потоке на определенное количество времени


int result = 0;
th1(Foo/*имя*/,2/*аргумент*/,3/*аргумент*/,std::ref(result)/*переменная которую можно изменить в функцию через обвёртку std::ref()*/);// через result можно вытянуть значения из потока

//Перебрать элементы в коллекции обычным циклом
#include<list>
template<typename T>
list<T> myList = { 12,15,643,675,345,76 };
for (auto i = myList.begin(); i != myList.end(); i++)//получаем итератор с начала коллекции, сравниваем с концом коллекции, инкрементируем
	cout << (*i) << endl;// разъименовуем итератор| *i - получаем данные лежащие в адресе, использовать только со звёздочкой
}
//Перебрать элементы в коллекции циклом range-based
#include<list>
template<typename T>
list<T> myList = { 12,15,643,675,345,76 };
for (const auto &var : myList) {//каждая итерация в цикле ссылаеться на элемент по итерации лежащий в коллекции и записывается в var(если не стоит амперсанд, то копируется, так дольше)
								// const что бы случайно не переписать данные в коллекции
	cout << var << endl;
}

//Перебрать элементы в коллекции циклом for each
#include<list>
template<typename T>
list<T> myList = { 12,15,643,675,345,76 };
for each(const auto &var in myList) {//каждая итерация в цикле ссылаеться на элемент по итерации лежащий в коллекции и записывается в var(если не стоит амперсанд, то копируется, так дольше)
									 // const что бы случайно не переписать данные в коллекции
	cout << var << endl;
}
--------------------------------------------------------------
#Лямбда-выражения | Лямбда-функции | Анонимные функции
void doWork(vector<int>vectOfNumb, function<void(int)>vectOfFunc) {
	for (auto var : vectOfNumb) {
		vectOfFunc(var);
	}
}

int main() {
	vector<int> vectorOfNumbers = { 2,5,7,8,0,6,13123,435,32,456,6723,452,56,645,867,34,524,12,645,435,234,6,4, 2 };
	vector<function<void(int)>> vectorOfFunc;

	int p = 0;
	cout << "P = " << p << endl;

	auto f = [&p](int a) {
		p = 5;
		cout << a << endl;
	};
	f(33);
	cout << "P = " << p << endl;

	function<void(int)> func;
	func = [](int arg) {
		cout << "Hello World " << arg << endl;
	};
	doWork(vectorOfNumbers, func);


	doWork(vectorOfNumbers, [](int arg) {
		cout << "Hello World " << arg << endl;
	});

	system("pause");
	return 0;
}
--------------------------------------------------------------
//Тонкости по анонимным функциям
auto *function;
function = [=]() {}			//захват по значению из вне лямбды
function = [&]() {}			//захват по сылке из вне лямбды
function = [=]() mutable {}	//mutable позволяет изменять захваченные переменные только внутри лямбды, из вне они не изменяются
function = []()->int {		//как определить тип возвращаемого значения лямбда-функции
	return something;
}
auto result = function();
--------------------------------------------------------------
//Как получить result из thread
#include<iostream>
#include<thread>
#include<chrono>
using namespace std;

int sum(int a, int b) {
	this_thread::sleep_for(chrono::seconds(3));
	cout << "Start Sum..." << endl;
	this_thread::sleep_for(chrono::seconds(5));
	cout << "Stop Sum..." << endl;
	return a + b;
}

int main() {
	int result = 0;
	thread th1([&result]() {
		result = sum(3, 6);
	});

	for (; result == 0;) {
		this_thread::sleep_for(chrono::milliseconds(500));
		cout << "something work....." << endl;
	}

	th1.join();

	cout << "Result Sum = " << result << endl;

	system("pause");
	return 0;
}
--------------------------------------------------------------
#Сравнение типов наследования
|Таблица
|--------------|-------------------------------------------------------------------|
|Базовый класс |				   Наследуемый класс получает					   |
|--------------|--------------------|----------------------|-----------------------|
|			   | public Наследование| private Наследование | protected Наследование|
|--------------|--------------------|----------------------|-----------------------|
|public		   | public				| private			   | protected			   |
|--------------|--------------------|----------------------|-----------------------|
|protected	   | protected			| private			   | protected			   |
|--------------|--------------------|----------------------|-----------------------|
|private	   | недоступно			| недоступно		   | недоступно			   |
|--------------|--------------------|----------------------|-----------------------|

--------------------------------------------------------------
//Как обьявить и инициализировать static переменую в классе

class Apple {
public:
	Apple() {count++;}
	~Apple() {}
private:
	static int countApple;
};

int Apple::countApple = 0;

void main() {
	Apple app1
	Apple app2
	Apple app3

	cout << app1.countApple << endl;
	cout << app2.countApple << endl;
	cout << app3.countApple << endl;
}
--------------------------------------------------------------
#Указатель на функцию
#include<iostream>
#include<string>
using namespace std;

string getDataFromServer() {
	return << "Data from Server" << endl;
}

string getDataFromWebSite() {
	return << "Data from Web" << endl;
}

string getDataFromClient() {
	return << "Data from Client" << endl;
}

void ShowDataOnMonitor(string (*someFunc)()) {
	cout << someFunc() << endl;
}

int main() {

	ShowDataOnMonitor(getDataFromServer);

	return 0;
}
--------------------------------------------------------------
//Указатель на функцию c агрументами для функции
string GetDataFromCustomer(int arg) {
	cout << arg << endl;
	return "Data from Customer";
}

typedef string(*Func)(int arg);
void ShowOnMonitor(Func func, int arg) {
	cout << func(arg) << endl;
}

int main() {
	ShowOnMonitor(GetDataFromCustomer, 15);

	system("pause");
	return 0;
}
--------------------------------------------------------------
//Как измерять время выполнения кода
#include<iostream>
#include<thread>
#include<string>
using namespace std;

class TimeOfWorkingProgram {
private:
	chrono::time_point<chrono::steady_clock> start;
	chrono::time_point<chrono::steady_clock> stop;
	chrono::duration<float> result;
	string nameOfTime;

public:
	TimeOfWorkingProgram(string nameOfTime) {
		this->nameOfTime = nameOfTime;
		start = chrono::high_resolution_clock::now();
	}

	~TimeOfWorkingProgram() {
		stop = chrono::high_resolution_clock::now();
		showResult();
	}

	void showResult() {
		result = stop - start;
		cout << nameOfTime << " Time - " << result.count() << endl;
	}
};

int sum(int a, int b) {
	TimeOfWorkingProgram time("local");
	cout << "---Start function---" << endl;
	this_thread::sleep_for(chrono::milliseconds(5000));
	cout << "---Stop function---" << endl;
	this_thread::sleep_for(chrono::milliseconds(5000));
	return a + b;
}

int main() {
	TimeOfWorkingProgram time("general");

	thread tr0(sum, 4, 5);

	for (int i(0); i < 20; i++) {
		this_thread::sleep_for(chrono::milliseconds(500));
		cout << "iteration " << i << endl;
	}

	tr0.join();

	system("pause");
	return 0;
}
--------------------------------------------------------------
//Исопльзование в потоках методы классов с помощью анонимных функций и без них
#include <thead>
#include <iostream>

using namespace std;

class MyClass {
private:

public:
	void foo() {}
	void bar(int arg) {}
	void baz(int arg1,int arg2) {}
}

int main() {
	MyClass mc;
	//First variant
	thread tr0([mc]() {
		mc.foo();
		mc.bar(5);
		mc.baz(7,3);
	});

	//Second variant
	thread th1(&MyClass::foo, mc);
	thread th2(&MyClass::bar, mc, 5);
	thread th3(&MyClass::baz, mc, 5, 7);

	system("pause");
	return 0;
}
--------------------------------------------------------------
#Mutex in thread

#include<iostream>
#include<thread>
#include<mutex>
using namespace std;

mutex mtx;

void print(char ch) {
	lock_guard<mutex> l_g(mtx);

	for (int i(0); i < 5; i++) {
		for (int j(0); j < 10; j++) {
			cout << ch;
			this_thread::sleep_for(chrono::milliseconds(20));
		}
		cout << endl;
	}
	cout << endl;
}

int main() {
	thread th0(print, '*');
	thread th1(print, '#');

	th0.join();
	th1.join();

	system("pause");
	return 0;
}
--------------------------------------------------------------
#STL
#Коллекции
//Для использования коллекции в своем коде используйте следующую директиву :

#include<>

//Итак, наиболее часто используются :
vector — коллекция элементов, сохраненных в массиве, изменяющегося по мере необходимости размера(обычно, увеличивающегося);
list — коллекция, хранящая элементы в виде двунаправленного связанного списка;
map — коллекция, сохраняющая пары вида, т.е.каждый элемент — это пара вида, при этом однозначная(каждому ключу соответствует единственное значение),
	где ключ — некоторая характеризующая значение величина, для которой применима операция сравнения; пары хранятся в отсортированном виде,
	что позволяет осуществлять быстрый поиск по ключу, но за это, естественно, придется заплатить : придется так реализовывать вставку,
	чтобы условие отсортированности не нарушилось;
set — это отсортированная коллекция одних только ключей, т.е.значений, для которых применима операция сравнения,
	при этом уникальных — каждый ключ может встретиться во множестве(от англ.set — множество) только один раз;
multimap — map, в котором отсутствует условие уникальности ключа, т.е.если вы произведете поиск по ключу,
	то получите не единственное значение, а набор элементов с одинаковым значением ключа; для использования в коде используется #include;
multiset — коллекция с тем же отличием от set’а, что и multimap от map’а, т.е.с отсутствием условия уникальности ключа; для подключения : #include.

#Строки
//Любая серьезная библиотека имеет свои классы для представления строк.В STL строки представляются как в формате ASCII, так и Unicode :
string — коллекция однобайтных символов в формате ASCII;
wstring — коллекция двухбайтных символов в формате Unicode; включается командой#include .

#Строковые потоки
strstream — используются для организации STL - строкового сохранения простых типов данных.
//Разбор примеров начнем именно с этого класса.
 
#include «stdafx.h»

using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	strstream xstr;
	for (int i = 0; i < 10; i++)
	{
		xstr << "Demo" << i << endl;
	}
	cout << xstr.str();
	string str;
	str.assign(xstr.str(), xstr.pcount());
	cout << str.c_str();
	return 0;
}
//Строковый поток — это буфер с нуль - терминатором в конце, поэтому при первой распечатке в конце строки оказывается мусор,
//	т.е.получить реальный конец можно не посредством нуль - терминатора, а получив счетчик : pcount().Затем «реальная часть» потока копируется в новую строку,
//	и мы получаем распечатку уже без мусора.

#Итераторы
//Очень важное понятие в реализации динамических структур данных — итератор.
//Неформально итератор можно определить как абстракцию, которая ведет себя как указатель,
//возможно, с какими - то ограничениями. Строго говоря, итератор — более общее понятие,
//и является объектной оберткой для указателя, поэтому указатель является итератором.
//Примерно его устройство может выглядеть так :
#include <iostream>
#include <vector>
#include <list>
using namespace std;

int main() {
	vector<int> myVector = { 2,4,5,8,3 };
	for (vector<int>::iterator it = myVector.begin(); it != myVector.end(); ++it) {
		cout << *(it + 0) << endl;// можно выполнять арифметику указателей и передвигатся по вектору с помощью суммы итератора и числа. С list так не прокатит.
	}

	list<int> myList = { 2,4,5,8,3 };
	for (auto it = myList.begin(); it != myList.end(); ++it) {
		cout << *it << endl;
	}

	//Что-бы передвинуть итератор в нужную позицию по List, используем:

	list<int>::iterator itList = myList.begin();
	advance(itList, 3);

	//Что-бы итератор не смог перезаписать данные в колекции присваиваем методы к тему cbegin() and cend()

	system("pause");
	return 0;
}

Вот несколько формализованных определений итератора :

//Итераторы обеспечивают доступ к элементам коллекции
//Для каждого конкретного класса STL итераторы определяются отдельно внутри класса этой коллекции.
//Существуют три типа итераторов :

(forward)iterator — для обхода коллекции от меньшего индекса к большему;
reverse iterator — для обхода коллекции от большего индекс к меньшему;
random access iterator — для обхода коллекции в любом направлении.

//Вот пример использования итераторов для удаления половин элементов коллекции :

using namespace std;

void printInt(int number)
{
	cout << number << endl;
}

int _tmain(int argc, _TCHAR* argv[])
{
	vector<int> myVec;
	vector<int>::iterator first, last;

	for (long i = 0; i < 10; i++){
		myVec.push_back(i);
	}
	first = myVec.begin();
	last = myVec.begin() + 5;

	if (last >= myVec.end()){
		return — 1;
	}

	myVec.erase(first, last);
	for_each(myVec.begin(), myVec.end(), printInt);
	return 0;
}

//Важно понимать, что при получении итератора на какой - то элемент коллекции и последующем изменении коллекции итератор может стать непригоден для использования.
//Итерация вперед и аналогично назад происходит так :
for (iterator element = begin(); element < end(); element++) { t = (*element); }

//При использовании random access iterator, например, так :
for (iterator element = begin(); element < end(); element += 2) { t = (*element); }

#Методы коллекций
//Основными методами, присутствующими почти во всех коллекциях являются следующие:
empty() — определяет, пуста ли коллекция;
size() — возвращает размер коллекции;
begin() — возвращает прямой итератор, указывающий на начало коллекции;
end() — возвращает прямой итератор, указывающий на конец коллекции, т.е.на несуществующий элемент, идущий после последнего;
rbegin() — возвращает обратный итератор на начало коллекции;
rend() — возвращает обратный итератор на конец коллекции;
clear() — очищает коллекцию, т.е.удаляет все ее элементы;
erase() — удаляет определенные элементы из коллекции;
capacity() — возвращает вместимость коллекции, т.е.количество элементов, которое может вместить эта коллекция(фактически, сколько памяти под коллекцию выделено);

//Методы Vector`a:
vector() - конструкто
~vector() - деструктор
operator = -присвоение контетна в{}
assing() - Заменяет содержимое контейнера(сколько ячеек, чем заполнить)
begin() - Возвращает итератор начала контейнера
cbegin() - Возвращает итератор начала контейнера с модификатором const
end() - Возвращает итератор конца контейнера + 1
cend() - Возвращает итератор конца контейнера + 1 с модификатором const
rbegin() - Возвращает итератор начала контейнера с реверсом цепочки
crbegin() - Возвращает итератор начала контейнера с реверсом цепочки с модификатором const
rend() - Возвращает итератор конца контейнера + 1 с реверсом цепочки
crend() - Возвращает итератор конца контейнера + 1 с реверсом цепочки с модификатором const
at() - Возвращает ссылку на элемент в указанном местоположении position с проверкой границ.
operator [] - Предоставляет доступ к указанному элементу через вписанный индекс
front() - Возвращает ссылку на первый элемент в контейнере
back() - Возвращает ссылку на последний элемент в контейнере
empty() - Проверки, если контейнер не имеет элементов, т.е.является ли begin() == end()
size() - Возвращает количество элементов в контейнере.std::distance(begin(), end())
max_size() - Возвращает максимальное количество элементов которое контейнер может содержать с учетом ограничений наложенных системой или реализацией
resize() - Изменяет размер контейнера.resize(count, value) count - Новый размер контейнера, value - значение для инициализации новых элементов
capacity() - Возвращает количество элементов, на которые в данный момент имееться в контейнер.
reserve() - Увеличьте емкость вектора до значения, которое больше или равно newCapacity.Если newCapacity больше текущей емкости(), выделяется новое хранилище, или же метод ничего не делает
shrink_to_fit() - Просит удаления неиспользуемых мощностей.Это необязательный просьбой сократить capacity в size.Это зависит от реализации, если запрос выполняется.
clear() - Удаляет все элементы из контейнера.Делает недействительными все ссылки, указатели или итераторы указывающие на удалённые элементы.
insert() - Вставляет элементы в указанную позицию в контейнере.insert(iterator pos, const T& value)
emplace() - Вставляет новый элемент в контейнере непосредственно перед pos.emplace(const_iterator pos, Args&&... args)
erase() - Удаляет указанные элементы из контейнера.erase(iterator pos)
push_back() - поместить элемент в конец
epmlace_back() - Добавляет новый элемент в конец контейнера.
pop_back() - Удаляет последний элемент из контейнера.
swap() - Обменивает содержимое контейнера с содержимым другого.swap(vector& other)
get_allocator() - Возвращает связанный аллокатор.

//Методы List`a:
list() - Создаёт list
~list() - Уничтожает list
operator = -Задаёт значения в контейнере
assign() - Заменяет содержимое контейнера(сколько ячеек, чем заполнить) предыдущие удаляет, остаються только установленны этой функцией
listOne.assign(listTwo.begin, listTwo.end) - копирование значений второго листа в первый лист с удаление предыдущей коллекции в первом листе
get_allocator() - Возвращает связанный аллокатор
front() - Предоставляет доступ к первому элементу
back() - Предоставляет доступ к последнему элементу
begin() - Возвращает итератор на первый элемент
cbegin() - Возвращает итератор на первый элемент с модификатором const
end() - Возвращает итератор на элемент, следующий за последним
cend() - Возвращает итератор на элемент, следующий за последним с модификатором const
rbegin() - Возвращает обратный итератор на первый элемент
crbegin() - Возвращает обратный итератор на первый элемент с модификатором const
rend() - Возвращает обратный итератор на элемент, следующий за последним
crend() - Возвращает обратный итератор на элемент, следующий за последним с модификатором const
empty() - Проверяет отсутствие элементов в контейнере
size() - Возвращает количество элементов в контейнере
max_size() - Возвращает максимально допустимое количество элементов в контейнере
clear() - Очищает контейнер
insert() - Вставляет элементы
emplace() - Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos
erase() - Удаляет элементы
push_back() - Добавляет элемент в конец
emplace_back() - Конструирует элементы "на месте" в конце контейнера
pop_back() - Удаляет последний элемент
push_front() - вставляет элементы в начало списка
emplace_front() - конструирует элементы "на месте" в начало списка
pop_front() - удаляет первый элемент
resize() - Изменяет количество хранимых элементов
swap() - Обменивает содержимое
merge() - слияние двух отсортированных списков
splice() - перемещает элементы из другого list
remove() - удаляет все встречаемые элементы коллекции которые указаны агрументом
remove_if() - удаляет элементы, удовлетворяющие определенным критериям
reverse() - инвертирует порядок элементов
unique() - удаляются последовательно повторяющихся элементов
sort() - сортирует элементы

//Meтоды something:

//Вместимость коллекции, как было сказано в начале, меняется по мере надобности, т.е.если вся выделенная под коллекцию память уже заполнена, 
//то при добавлении нового элемента вместимость коллекции будет увеличена, а все значения, бывшие в ней до увеличения, 
//будут скопированы в новую область памяти — это довольно «дорогая» операция.Убедиться в том, что размер и вместимость — разные вещи, можно на следующем примере :

vector<int> vec;
cout << "Real size of array in vector: " << vec.capacity() << endl;

for (int j = 0; j < 10; j++){
	vec.push_back(j);
}

cout << «Real size of array in vector : « << vec.capacity() << endl;
return 0;

//Самая часто используемая коллекция — это вектор.
//Очень удобно, что у этой коллекции есть такой же оператор operator [], что и у обычного массива.
//Такой же оператор есть и у коллекций map, deque, string и wstring.

//Важно понимать, что вместимость vector изменяется динамически.
//Обычно для увеличения размера используется мультипликативный подход:
//выделенная под vector память увеличивается при необходимости в константное число раз, т.е.
//если добавление нового элемента приведет к тому, что размер массива превысит вместимость, 
//то операционной системой для программы будет выделен новый участок памяти, например, 
//в два раза больший, в который будут скопированы все значения из старого участка памяти и к которому будет дописано новое значение.

#Алгоритмы
//Разработчики библиотеки STL ставили перед собой гораздо более серьезную задачу, чем создание библиотеки с набором шаблонных структур данных.
//STL содержит огромный набор оптимальных реализаций популярных алгоритмов, позволяющих работать с STL - коллекциями.
//Все реализованные функции можно поделить на три группы:

//Методы перебора всех элементов коллекции и их обработки:

//Методы перебора всех элементов коллекции и их обработки: 
count, count_if, find, find_if, adjacent_find, for_each, mismatch, equal, 
search copy, copy_backward, swap, iter_swap, swap_ranges, fill, fill_n, generate, 
generate_n, replace, replace_if, transform, remove, remove_if, remove_copy, 
remove_copy_if, unique, unique_copy, reverse, reverse_copy, rotate, rotate_copy, 
random_shuffle, partition, stable_partition

//Методы сортировки коллекции: 
sort, stable_sort, partial_sort, partial_sort_copy, nth_element, binary_search,
lower_bound, upper_bound, equal_range, merge, inplace_merge, includes, set_union,
set_intersection, set_difference, set_symmetric_difference, make_heap, push_heap,
pop_heap, sort_heap, min, max, min_element, max_element, lexographical_compare,
next_permutation, prev_permutation

//Методы выполнения определенных арифметических операций над членами коллекций: 
Accumulate, inner_product, partial_sum, adjacent_difference

#Предикаты
//Для многих алгоритмов STL можно необходимо задать условие, посредством которого алгоритм определит, что ему делать с тем или иным членом коллекции.
//Предикат — это функция, которая принимает несколько параметров и возвращает логическое значение(истина / ложь).Существует и набор стандартных предикатов.

#Потокобезопасность
//Важно понимать, что STL — не потокобезопасная библиотека.Но решить эту проблему очень просто : если два потока используют одну коллекцию,
//просто реализуйте критическую секцию и Mutex.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#QT

1#
label = метка
#include <QLabel> // для роботы с текстом

2#
QLabel *label = new QLabel("Hello");
label.resize(X, Y); // изменение размера окна в пикселях
label->show(); // вывод текста в главное окно

У обьектов есть имена, зарание нужно их переименовывать под свои задачи
У главного окна есть ToolBar и StatusBar

ui->label->setText("Кнопка нажата!!!"); // получили доступ к обьектам главного окна, выбрали обьект с именем label и применяем к нему метод изменения текста на свой 

3#
#include <QMessageBox>
QMessageBox::about(this, "Заголовок", "Просто текст внутри"); // просто текст о чём-то
QMessageBox::aboutQT(this, "Заголовок"); // текст об QT
QMessageBox::critical(this, "Заголовок", "Просто текст внутри"); // текст с логом ошибки, хорошо для каких то ошибок
QMessageBox::information(this, "Заголовок", "Просто текст внутри"); // текст для информации
QMessageBox::warning(this, "Заголовок", "Просто текст внутри"); // текст с предупреждением!
QMessageBox::question(this, "Заголовок", "Просто текст внутри", QMessageBox::Yes | QMessageBox::No); // текст с вопросом который возвращает Yes or No, можно присвоить другим переменным и потом сравнивать

#include <qDebug>

QMessageBox::StandardButton reply = QMessageBox::question(this, "Заголовок", "Просто текст внутри", QMessageBox::Yes | QMessageBox::No);

if (reply == QMessageBox::Yes) {
	QApplication::quit();
}
else {
	qDebug() << "Кнопка НЕТ была нажата!";
}

так же в QT есть слои которые можно как на основу ставить, так и на особые участки налаживать

Добавление нового окна
Кликаем на папку с проэктом->пкм->QT - Класс формы->QT Designer->выбрать->Dialog without->именуем его->готово

что бы открыть новое окно, мы создаём кнопку, что бы открывать новое окно, создаём слот и...

4#
#include "secondwindow.h" // подключение класса второго окна
void MainWindow::on_pushButton_clicked()
{
	SecondWindow window; // создание экземпляра окна
	window.setModal(true); // установка модальности окна
	window.exec(); //выполнить, execute - выполнять
} // в таком случае будет только одно активное окно (SecondWindow)

//для множества активных окон

заходим в заголовочный файл основного окна, подключаем заголовочный файл второго окна

#include "secondwindow.h"

в классе MainWindow в модификаторе доступа private создаём указатель

private:
	SecondWindow *window;

	в Реализации класа MainWindow...
		void MainWindow::on_pushButton_clicked()
	{
		hide(); // скрывает предведущие окна
		window = new SecondWindow(this);// выделяем память под новое окно
		window->show(); // показываем окно
	}// так мы можем создавать множество окон и каждый может быть активным

	Авторизация и проверка введённых данных
		Создаём поля для ввода и кнопку для принятия ввода
#include <QMessageBox> 

		void MainWindow::on_pushButton_clicked()
	{
		QString login = ui->login->text();
		QString password = ui->pass->text();

		if (login == "IGORAFAN" && pass == "2143") {
			QMessageBox::information(this, "Доступ", "Вход Выполнен");
		}
		else {
			QMessageBox::warning(this, "Доступ", "Вход НЕ выполнен!!!");
		}
	}

	5#
		Добавление изображения в интерфейс

		Отдельного компонента для добавления изображения нет, но можно через label->найти параметр pixmap->выбрать файл->файл на ПК
		//Изобрадение появится при условии что файл постоянно будет лежать в директории на одном ПК

		Вывод инфы в StatusBar
#include <QMessageBox> 

		void MainWindow::on_pushButton_clicked()
	{
		QString login = ui->login->text();
		QString password = ui->pass->text();

		if (login == "IGORAFAN" && pass == "2143") {
			//QMessageBox::information(this,"Доступ","Вход Выполнен");
			ui->statusBar->showMessage("Вход Выполнен");
		}
		else {
			//QMessageBox::warning(this,"Доступ","Вход НЕ выполнен!!!");
			ui->statusBar->showMessage("Вход НЕ Выполнен!");
		}
	}

	Подключение изображения при помощи кода
		Кликаем на папку с проэктом->пкм->добавить новый->файл ресурсов QT->называм resource->В папке с проэктом, создаём ещё одну папку img и в неё вкладываем изображение->
		Затем выбираем resource.qrc->добавить префикс / resource->добавить файл->выбираем файл в папке->добавляем->копируем путь к файлу "/resource/img/home.png" ->
		Переходим в MainWindow.cpp->подключаем библиотеку #include <QPixmap>

#include <QPixmap>

		MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) {
		ui->setupUi(this);
		QPixmap pix("/resource/img/home.png"); // создание экземпляра изображение с именем pix от класса QPixmap c путём в агрументах
		int w = ui->imageHome->width(); // создаём переменную ширины и присваиваем рамзмеры на модели
		int h = ui - .imageHome->height();// создаём переменную высоту и присваиваем рамзмеры на модели

		ui->image->setPixmap(pix.scaled(w, h, Qt::KeepAspectRatio)); //задаём изображению свойство маштабироватся при расстягивании и сужении окна
	}

	6#
		Проверка на то, стоит галочка или нет ?
		Создаём кнопку, затем checkBox, на кнопку присваиваем слот по нажатию...

		void MainWindow::on_checkBox_stateChanged(int arg1) { // работает если нажимать по полю для галочки
		if (ui->checkBox->isChecked()) {
			ui->statusBar->showMessage("галочка поставлена");
		}
		else {
			ui->statusBar->showMessage("галочка НЕ нажата");
		}
	}

	void MainWindow::on_on_pushButton_clicked() { // работает если нажимать по кнопке
		if (ui->checkBox->isChecked()) {
			ui->statusBar->showMessage("галочка поставлена");
		}
		else {
			ui->statusBar->showMessage("галочка НЕ нажата");
		}
	}

	работаем с radioButton c именами John, Michael, Azek, Elon
		void MainWindow::on_mainButton_clicked() {
		if (ui->John->isChecked() && ui->Azek->isChecked()) {
			ui->statusBar->showMessage("selected John and Azek");
		}
		else if (ui->John->isChecked() && ui->Elon->isChecked()) {
			ui->statusBar->showMessage("selected John and Elon");
		}
		else if (ui->Michael->isChecked() && ui->Azek->isChecked()) {
			ui->statusBar->showMessage("selected Michael and Azek");
		}
		else if (ui->Michael->isChecked() && ui->Elon->isChecked()) {
			ui->statusBar->showMessage("selected Michael and Elon");
		}
	}
	7#
		Создание меню с QAction, QMenu и QToolBar
		Что бы добавить картинки в наше меню, мы по главной папке проэкта правой клавишей миши Кликаем
		и выбираем->Добавить новый->QT->Файл ресурсов QT->добавляем имя / путь->Создалась папка
		с внутрянкой.qrc->В ней выбираем "добавить префикс" / rec->Заходим в папку проэкта->создаём новую папку ->
		перекидываем картинки->в самом.qrc выбираем "добавить файлы"->выбираем наши картинки.
		Далее Переходим в граф.ред.к меню привязываем картинки -> 2х кликаем по элементу->выбираем choose resource->Выбираем наши картинки.

		Добавления элементов функционала в ToolBar простым перетягиванием элемента на линию ToolBar.
		Выбираем наш элемент функционала изи QMenu и "перейти к слоту"
		void MainWindow::on_action_triggered() {
		ui->statusBar->showMessage("Создание нового проэкта");
	}
	void MainWindow::on_action1_triggered() {
		ui->statusBar->showMessage("Открытие нового проэкта");
	}
	void MainWindow::on_action2_triggered() {
		ui->statusBar->showMessage("Закрытие проэкта");
		QApplication::quit();
	}

	changed(); -
		hovered(); -
		toggled(bool); -
		triggered(); -при клике
		triggered(bool); -
		destroyed(); -
		destroyed(QObject*); -
		objectNameChanget(QString); -

		8#
		Создание списка(QListWidget)
		Создаём новый проэкт, на форму нужного окна накидываем ListWidget,
		компонуем его, докинем ещё кнопку "выбрать элемен"
		В конструкторе главного окна добавляем

		MainWindow::MainWindow(QWidget *parent) :QMainWindow(parent)
		ui(new Ui::MainWindow)
	{
		ui->setupUi(this)
			ui - listWidget->addItem("Audi");		 // добавляем элементы
		ui - listWidget->addItem("Mersedes");	 // добавляем элементы
		ui - listWidget->addItem("BMW");		 // добавляем элементы
		ui - listWidget->addItem("Volkswagen");// добавляем элементы
	}

	Что бы выводить выбраный элемен в спеске куда - то к примеру в statusBar, мы делаем...
		На кнопку "выбрать элемен" накидываем перейти к слоту и выбираем clicked();
	void MainWindow::on_pushButton_clicked() {
		ui->statusBar->showMessage(ui->ListWidget->currentItem()->text());
	}

	Что бы добавить картинки в наш список в элементам, то к каждому элементу
		добавляем указатель на список(QIcon("/путь из проэкта"))
		MainWindow::MainWindow(QWidget *parent) :QMainWindow(parent)
		ui(new Ui::MainWindow)
	{
		ui->setupUi(this)
			QListWidgetItem *item_1 = new QListWidget(QIcon("/путь из проэкта"))
			ui - listWidget->addItem("Audi");		 // добавляем элементы
		QListWidgetItem *item_2 = new QListWidget(QIcon("/путь из проэкта"))
			ui - listWidget->addItem("Mersedes");	 // добавляем элементы
		QListWidgetItem *item_3 = new QListWidget(QIcon("/путь из проэкта"))
			ui - listWidget->addItem("BMW");		 // добавляем элементы
		QListWidgetItem *item_4 = new QListWidget(QIcon("/путь из проэкта"))
			ui - listWidget->addItem("Volkswagen");// добавляем элементы
	}

	Что бы окрасить выбранный элемент каким - то цветом, нужно
		void MainWindow::on_pushButton_clicked() {
		ui->statusBar->showMessage(ui->ListWidget->currentItem()->text());

		ui->ListWidget->currentItem()->setBackgroundColor(Qt::Blue);// синее выделение к примеру
		ui->ListWidget->currentItem()->setForeground(Qt::Silver);// серый текст к примеру
	}

	#9
		Создание Дизайна Калькулятора

		#10
		Создание Калькулятора(Ввод чисел)
		Прописываем слоты вручную
		//mainwindow.h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>

		namespace Ui {
		class MainWindow;
	}

	class MainWindow : public QMainWindow
	{
		Q_OBJECT

	public:
		explicit MainWindow(QWidget *parent = 0);
		//MainWindow();
		~MainWindow();
	private:
		Ui::MainWindow *ui;

	private slots:
		void digits_numbers();

	};

#endif // MAINWINDOW_H

	//mainwindow.cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"

	MainWindow::MainWindow(QWidget *parent) :
		QMainWindow(parent),
		ui(new Ui::MainWindow)
	{
		ui->setupUi(this);
		//Каждый раз когда мы будем нажимать на кнопку,будем отслеживать сигнал 
		//и при нажатии будем вызывать метод digits_numbers();
		//При нажатии на одну из указаных кнопок,вызывается один метод, общий для них
		connect(ui->on_pushButton_0, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_1, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_2, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_3, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_4, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_5, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_6, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_7, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_8, SIGNAL(clicked()), this, SLOT(digits_numbers()));
		connect(ui->on_pushButton_9, SIGNAL(clicked()), this, SLOT(digits_numbers()));

	}

	MainWindow::~MainWindow()
	{
		delete ui;
	}

	void MainWindow::digits_numbers() {
		QPushButton *button = (QPushButton *)sender();

		double all_numbers;
		QString new_label;
		all_numbers = (ui->result_show->text() + butto->text()), toDouble();
		new_label = QString::number(all_numbers, 'g', 15);

		ui->result_show->setText(new_label);
	}

	//методы для поиска текста в файле
	void FindText::loadTextFile() {
		QFile inputFile(":/input.txt");
		inputFile.open(QIODevice::ReadOnly);

		QTextStream in(&inputFile);
		QString line = in.readAll();
		inputFile.close();

		ui->textEdit->setPlainText(line);
		QTextCursor cursor = ui->textEdit->textCursor();
		cursor.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
	}
	//Поиск слов в тексте
	void FindText::on_pushButton_clicked()
	{
		QString searchString = ui->lineEdit->text();
		ui->textEdit->find(searchString, QTextDocument::FindWholeWords);
	}
	//Сохранение данных в файл QT
	void AddressBook::saveToFile() { //при нажатии на кнопку Save
		QString fileName = QFileDialog::getSaveFileName(this, //метод создающий диалоговое окно для сохранения файлов и возвращает имя введённое пользователем для файла + дописанным форматом файла
			tr("Save Address Book"), "", //установленный заголовок диалогового окна
			tr("Address Book (*.abk);;All Files (*)")); //установленый свой уникальный формат или формат файла

		if (fileName.isEmpty()) //если введенное имя для пользователя пустое или не введённое, то
			return; //просто выходим из метода(пусть пользователь повторяет процедуру)
		else { //или же
			QFile file(fileName); //создаём обьект класса QFile и в него вкидываем имя файла + дописанным форматом файла

			if (!file.open(QIODevice::WriteOnly)) { //если файл не был открыт для записи
				QMessageBox::warning(this, tr("Unable to open file"), //выводим предупреждение
					file.errorString()); //Возвращает описание последней ошибки устройства.
				return;
			}

			QDataStream out(&file); //создём стрим файла с таким-то именем
			out.setVersion(QDataStream::Qt_4_3); //устанавливаем версию
			out << contacts; //стримим цепочку(список)
		}
	}
	//Загрузка данных из файла
	void AddressBook::loadFromFile() {//при нажатии на кнопку Load
		QString fileName = QFileDialog::getOpenFileName(this,
			tr("Open Address Book"), "",
			tr("Address Book (*.abk);;All Files (*)"));

		if (fileName.isEmpty())
			return;
		else {
			QFile file(fileName);

			if (!file.open(QIODevice::ReadOnly)) {
				QMessageBox::information(this, tr("Unable to open file"),
					file.errorString());
				return;
			}

			QDataStream in(&file); in.setVersion(QDataStream::Qt_4_3);
			contacts.empty(); // очистка существующих контактов
			in >> contacts;

			QMap < QString, QString > ::iterator i = contacts.begin();
			nameLine->setText(i.key());
			addressText->setText(i.value());
		}
	}

	//экспорт данных в vCard Windows для контактов
	void AddressBook::exportAsVCard() {//при нажатии на кнопку Export
		QString name = nameLine->text();
		QString address = addressText->toPlainText();
		QString firstName;
		QString lastName;
		QStringList nameList;

		int index = name.indexOf(" ");

		if (index != -1) {
			nameList = name.split(QRegExp("\\s+"), QString::SkipEmptyParts);
			firstName = nameList.first();
			lastName = nameList.last();
		}
		else {
			firstName = name;
			lastName = "";
		}

		QString fileName = QFileDialog::getSaveFileName(this,
			tr("Export Contact"), "",
			tr("vCard Files (*.vcf);;All Files (*)"));

		if (fileName.isEmpty())
			return;

		QFile file(fileName);

		if (!file.open(QIODevice::WriteOnly)) {
			QMessageBox::information(this, tr("Unable to open file"),
				file.errorString());
			return;
		}

		QTextStream out(&file);

		out << "BEGIN:VCARD" << "\n";
		out << "VERSION:2.1" << "\n";
		out << "N:" << lastName << ";" << firstName << "\n";

		if (!nameList.isEmpty())
			out << "FN:" << nameList.join(" ") << "\n";
		else
			out << "FN:" << firstName << "\n";

		address.replace(";", "\\;", Qt::CaseInsensitive);
		address.replace("\n", ";", Qt::CaseInsensitive);
		address.replace(",", " ", Qt::CaseInsensitive);

		out << "ADR;HOME:;" << address << "\n";
		out << "END:VCARD" << "\n";

		QMessageBox::information(this, tr("Export Successful"),
			tr("\"%1\" has been exported as a vCard.").arg(name));
}

//как вывести сообщение в консоль
QString fileName = "tempword";
qDebug() << fileName;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#SFML
//Шаблон для запуска первого окна окна
#include <SFML/Graphics.hpp>
using namespace sf;
int main()
{
	RenderWindow window(VideoMode(600, 400), "My Lesson`s Window");
	window.setVerticalSyncEnabled(1);

	while (window.isOpen()) {
		Event event;
		while (window.pollEvent(event)) {
			if (event.type == Event::Closed)
				window.close();
		}

		window.clear();
		window.display();
	}
	return 0;
}
------------------------------------------------------------------------
//Число Фибоначчи
long fibonacci(unsigned n)
{
	if (n < 2) return n;
	return fibonacci(n - 1) + fibonacci(n - 2);
}
------------------------------------------------------------------------
//загрузка Изображения, текстуры, спрайта
Image heroImage;
heroImage.loadFromFile("images/hero.png");

Texture heroTexture;
heroTexture.loadFromImage(heroImage);

Sprite heroSprite;
heroSprite.setTexture(heroTexture);
------------------------------------------------------------------------
//Установка rectangle для спрайта
heroSprite.setTextureRect(IntRect(96, 192, 96, 96));//(вправо,вниз,ширина,высота)//(позиция rect, размеры rect)
------------------------------------------------------------------------
//Телепортация картинки
float heroTeleportTimer = 0;
heroTeleportTimer += time;

if (heroTeleportTimer > 3000) {
	heroSprite.setPosition(0, 120);
	heroTeleportTimer = 0;
}
